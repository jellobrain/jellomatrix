<?php

/**
 * @file
 * Module file for jellomatrix.
 */

use Drupal\Core\Block\BlockPluginInterface;

/**
 * @defgroup jellomatrix Jellomatrix Block
 * @ingroup jellomatrix
 * @{
 * Demonstrates code creation of blocks.
 *
 * This example demonstrates how a module can define blocks that can be
 * displayed on various pages of a site, and how to alter blocks provided by
 * other modules.
 */

/**
 * Implements hook_block_view_alter().
 *
 * This hook allows you to modify the output of any block in the system.
 *
 * We are going to change the block label to uppercase if it contains the string
 * "uppercase" or if the default block label contains this string. The default
 * block label is set programmatically in the subject key of the block's plugin
 * definition. The configurable block label, which can be overridden through the
 * UI, is found in the "#configuration" key of the block's build definition.
 * This module creates a block that demonstrates the uppercase effect in the
 * "Example: uppercase this please" block. You can also demonstrate the effect
 * of this hook by editing the title of an existing block or by creating a new
 * block which where the default label has the string "uppercase" in it.
 *
 * Instead of hook_block_view_alter(), which is called for all blocks, you can
 * also use hook_block_view_BASE_BLOCK_ID_alter() to alter a specific block. To
 * only change the "example_uppercase" block we would use the function:
 * hook_block_view_example_uppercase_alter().
 */
function jellomatrix_block_view_alter(array &$build, BlockPluginInterface $block) {
  // We'll search for the string 'uppercase'.
  $definition = $block->getPluginDefinition();
  if ((!empty($build['#configuration']['label']) && mb_strpos($build['#configuration']['label'], 'uppercase')) || (!empty($definition['subject']) && mb_strpos($definition['subject'], 'uppercase'))) {
    // This will uppercase the block title.
    $build['#configuration']['label'] = mb_strtoupper($build['#configuration']['label']);
  }
}

/**
 * @} End of "defgroup jellomatrix".
 */


/**
 * Implements hook_theme().
 */
function jellomatrix_theme($existing, $type, $theme, $path) {
  return array (
    'jellomatrix' => array(
      'render element' => 'custom_page',
      'path' => $path . '/templates',
      'template' => 'jellomatrix',
    ),
  );
}

function jellomatrix_primes($tone) {
  $primes = array();
  $primes[] = 1;
  // Numbers to be checked as prime.
  for($i=1;$i<=$tone;$i++){
		$counter = 0;
    // All divisible factors.
		for($j=1;$j<=$i;$j++){
			if($i % $j==0){
				$counter++;
			}
		}
		// Prime requires 2 rules ( divisible by 1 and divisible by itself).
		if($counter==2){
			$primes[] = $i;
	  }
  }
  return $primes;
}

// BOOKMARK: OUTPUT BLOCKS

function jellomatrix_output_basegrid($scale_increments, $prime_matrix, $primes, $tone, $interval, $scaled, $scales) {
  $output = '';

  $output .= '<div class="begintext"><p><a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png" /></a><br /><span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/InteractiveResource" property="dct:title" rel="dct:type">Jellomatrix</span> by <a xmlns:cc="http://creativecommons.org/ns#" href="https://www.jellobrain.com" property="cc:attributionName" rel="cc:attributionURL">Ana Willem</a> is licensed since 2007 under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License</a>.<br />Based on a work at <a xmlns:dct="http://purl.org/dc/terms/" href="https://www.jellobrain.com" rel="dct:source">https://www.jellobrain.com</a>.</p></div><hr class="hr">';

  $output .= '<div class="begintext">';

  if (isset($scale_increments)) {
    $output .= '<div class="floatright"><h3>You have scales!</h3></div>';
  }
  else {
    $output .= '<div class="floatright"><h3>Not scale active. Try again!</h3></div>';
  }
  $output .= '</div><hr class="hr"><br></div>';
  $output .= '<div class="begingrid"><h3>The Original Matrix</h3><div class="endtext"><br></div>';
  $output .= '<table class="table begingrid" cols="' . $tone . '" rows="' . $interval . '">';
  $totalcount = $tone*$interval;
  foreach($prime_matrix as $prime_row) {
    $output .= '<tr>';
    $count = 0;
    foreach($prime_row as $item) {
      if ($item['tone']%2 != 0) {
        $color = 'white';
      }
      if ($item['tone']%2 == 0) {
        $color = 'subhighlight';
      }
      foreach ($primes as $prime) {
        if ($item['tone'] == $prime) {
          $color = 'white';
            if ($item['tone']%2 == 0) {
              $color = 'highlight';
            }
        }
      }

      /*dpm($scales);*/
      if ($item['tone'] == $scales['h'][$count]) {
        $output .= '<td class="tdgrid ' . $color . ' blue-text">' . $item['tone'] . '</td>';
      }
      elseif ($item['tone'] == $scales['f'][$count]) {
        $output .= '<td class="tdgrid ' . $color . ' groen-text">' . $item['tone'] . '</td>';
      }
      elseif ($item['tone'] == $scales['b'][$count]) {
        $output .= '<td class="tdgrid ' . $color . ' salmon-text">' . $item['tone'] . '</td>';
      }
      else {
        $output .= '<td class="tdgrid ' . $color . ' red-text">' . $item['tone'] . '</td>';
      }
      $count++;
    }
    $output .= '</tr>';
  }
  $output .= '</table></div><p><br/></p><div class="endtext"><br></div>';

  $output .= '<div class="begintext"><p><h3>Scale Pattern:</h3></p>';
  $output .= '<p>Whether you look at each row individually, or look at each diagonal row (in forward or backward \'slash\' ';
  $output .= 'directions) you will notice that the order of numbers is consistent on every row (or each direction of diagonal rows) ';
  $output .= 'and that only the starting number differs from row to row.  I refer to this as a \'scale\'.  If the scale were ';
  $output .= 'to be played in a circle consisting of the numbers of the first \'tone\' value, the shape formed would be the ';
  $output .= 'same regardless of which number you start with.';
  $output .= '</p>';
  $output .= '<p><img src="/sites/default/files/h_circle.png?t='. time().'" />';
  $output .= '&nbsp;<img src="/sites/default/files/f_circle.png?t='. time().'" />';
  $output .= '&nbsp;<img src="/sites/default/files/b_circle.png?t='. time().'" /></p><div class="endtext"><br></div></div>';
  $output .= '<p><strong>' . $scaled . '...</strong></p><hr class="hr"><p><br/></p><div class="endtext"><br></div>';
  $output .= '<div class="begintext"><p><a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png" /></a><br /><span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/InteractiveResource" property="dct:title" rel="dct:type">Jellomatrix</span> by <a xmlns:cc="http://creativecommons.org/ns#" href="https://www.jellobrain.com" property="cc:attributionName" rel="cc:attributionURL">Ana Willem</a> is licensed since 2007 under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License</a>.<br />Based on a work at <a xmlns:dct="http://purl.org/dc/terms/" href="https://www.jellobrain.com" rel="dct:source">https://www.jellobrain.com</a>.</p></div><hr class="hr">';

  return $output;
}


// BOOKMARK: OUTPUT BLOCKS

function jellomatrix_output_splicegrid_basic($spliced_matrix, $primes, $tone, $interval) {
  $output = '';

  // And then we create the spliced matrix grid.
  $output .= '<div class="begintext endtable"></div><div class="begingrid"><h3>The Basic Orientation of the Spliced Matrix</h3>';
  $output .= '<p>';
  $output .= 'Why splice the initial matrix?  This started out as a hunch, but also following the work of Jose Arguilles who ';
  $output .= 'inspired this up to a point.  But also the work of Mark Rothko and Randy Powell with their ABHA torus to which ';
  $output .= 'the matrix forms here bare some relation but which diverge from what Randy and Mark are doing in important ways. ';
  $output .= 'In my mind, splicing the matrix creates an architecture that reminded me of a battery.  I do not think this analogy ';
  $output .= 'is off-base. When we combine this notion while also looking for the patterns in the \'scales\' found in the original matrix, ';
  $output .= 'we see emergent patterns and pathways.  The next progression of images takes you through a categorization of some of those patterns.';
  $output .= '</p>';
  $output .= '<table class=" table begingrid" cols="' . $tone*2 . '" rows="' . $interval . '">';

  $request = \Drupal::request();
  $current_path = $request->getPathInfo();
  $path_args = explode('/', $current_path);
  if (isset($path_args[4])) {
    $doubleflip = $path_args[4];
  }

  for ($i = 1; $i <= $interval; $i++) {
    $output .= '<tr>';
    $count = 1;
    foreach ($spliced_matrix as $spliced_row) {
      foreach ($spliced_row as $item) {
        if ($item['row'] == $i) {
          $prime = jellomatrix_primes($tone);
          if (($item['column'])%2 == 0) {
            $item['color'] = 'green-text';
          }
          if (($item['column'])%2 != 0) {
            $item['color'] = 'red-text';
          }
          if ($item['column'] == 1 && $item['row'] == 1) {
            $item['background'] = 'green';
            $item['opacity'] = '.' . $item['tone'];
          }
          if (isset($doubleflip) && $doubleflip == 'doubleflip') {
            if ($item['column'] == 2*$tone && $item['row'] == $interval) {
              $item['background'] = 'green';
              $item['opacity'] = '.' . $item['tone'];
            }
          }
          else {
            if ($item['column'] == 2 && $item['row'] == $interval) {
              $item['background'] = 'green';
              $item['opacity'] = '.' . $item['tone'];
            }
          }
          $output .= '<td class="' . $item['column'] . 'x-' . $item['row'] . 'y ' .$item['color'] . ' tdgrid ' .$item['background'] . '">' . $item['tone'] . '</td>';
          $count++;
        }
      }
    }
    $output .= '</tr>';
  }
  $output .= '</table><div><hr class="hr"></div></div>';

  return $output;
}


// BOOKMARK: OUTPUT BLOCKS

function jellomatrix_output_splicegrid_primes($spliced_matrix, $primes, $tone, $interval) {
  $output = '';

  // And then we create the spliced matrix grid.
  $output .= '<div class="begintext endtable"></div><div class="begingrid"><h3>HIGHLIGHTING PRIMES: The Spliced Matrix</h3><table class="table begingrid" cols="' . $tone*2 . '" rows="' . $interval . '">';
  for ($i = 1; $i <= $interval; $i++) {
    $output .= '<tr>';
    $count = 1;
    foreach ($spliced_matrix as $spliced_row) {
      foreach ($spliced_row as $item) {
        if ($item['row'] == $i) {
          $prime = jellomatrix_primes($tone);
          if (($item['column'])%2 == 0) {
            $item['color'] = 'green-text';
          }
          if (($item['column'])%2 != 0) {
            $item['color'] = 'red-text';
          }
          if (in_array($item['tone'], $primes)) {
            $item['background'] = 'highlight';
            $item['opacity'] = '.' . $item['tone'];
          }
          if (!in_array($item['tone'], $primes)) {
            $item['background'] = 'white';
            $item['opacity'] = '.' . $item['tone'];
          }
          $output .= '<td class="' . $item['column'] . 'x-' . $item['row'] . 'y ' .$item['color'] . ' tdgrid ' .$item['background'] . '">' . $item['tone'] . '</td>';
          $count++;
        }
      }
    }
    $output .= '</tr>';
  }
  $output .= '</table><div><hr class="hr"></div></div>';

  return $output;
}


// BOOKMARK: OUTPUT BLOCKS

function jellomatrix_output_splicegrid_evenodd($spliced_matrix, $primes, $tone, $interval) {
  $output = '';

  // And then we create the spliced matrix grid.
  $output .= '<div class="begintext endtable"></div><div class="begingrid"><h3>HIGHLIGHTING EVEN+ODD: The Spliced Matrix</h3><table class="table begingrid" cols="' . $tone*2 . '" rows="' . $interval . '">';
  for ($i = 1; $i <= $interval; $i++) {
    $output .= '<tr>';
    $count = 1;
    foreach ($spliced_matrix as $spliced_row) {
      foreach ($spliced_row as $item) {
        if ($item['row'] == $i) {
          $prime = jellomatrix_primes($tone);
          if (($item['column'])%2 == 0) {
            $item['color'] = 'green-text';
          }
          if (($item['column'])%2 != 0) {
            $item['color'] = 'red-text';
          }
          if (($item['tone'])%2 == 0) {
            $item['background'] = 'white';
            $item['opacity'] = '.' . $item['tone'];
          }
          if (($item['tone'])%2 != 0) {
            $item['background'] = 'highlight';
            $item['opacity'] = '.' . $item['tone'];
          }
          $output .= '<td class="' . $item['column'] . 'x-' . $item['row'] . 'y ' . $item['color'] . ' tdgrid  ' . $item['background'] . '">' . $item['tone'] . '</td>';
          $count++;
        }
      }
    }
    $output .= '</tr>';
  }
  $output .= '</table><div class="hr begintext"><p>Interstingly enough, the sections which seem to hold information about the vortec/ies they reflect seem to fall most often in the middle of the sine waves created by what appear to be very different "environments" or "gradients" between higher frequency oscillations of even and odd numbers (you might need to squint your eyes to see them), They are the waves defined by the more or less frequent oscillatory patterns taken as a whole.  More about this in the "Rows" calculations in the "Increments" section below.</p><hr class="hr"></div></div>';

  return $output;
}


// BOOKMARK: OUTPUT BLOCKS

function jellomatrix_output_splicegrid_waveforms($spliced_matrix, $splied_matrix_reversed, $primes, $tone, $interval, $boolean, $scaled/*, $scales*/)
{
  $output = '';
  $output .= '<div class="begintext"><p><a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png" /></a><br /><span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/InteractiveResource" property="dct:title" rel="dct:type">Jellomatrix</span> by <a xmlns:cc="http://creativecommons.org/ns#" href="https://www.jellobrain.com" property="cc:attributionName" rel="cc:attributionURL">Ana Willem</a> is licensed since 2007 under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License</a>.<br />Based on a work at <a xmlns:dct="http://purl.org/dc/terms/" href="https://www.jellobrain.com" rel="dct:source">https://www.jellobrain.com</a>.</p></div><hr class="hr">';
  if (!empty($spliced_matrix_reversed)) {
    foreach ($spliced_matrix_reversed as $spliced_row_reversed) {
      foreach ($spliced_row_reversed as $item) {
        if (isset($item['phase_color']) && !isset($item['wave_limit'])) {
          $reversed = 'reversed';
        }
      }
    }
  }
  foreach ($spliced_matrix as $spliced_row) {
    foreach ($spliced_row as $item) {
      if (isset($item['phase_color']) && !isset($item['wave_limit'])) {
        $forward = 'forward';
      }
    }
  }

  if (isset($reversed) && isset($forward)) {
    $direction = 'Bi-directional';
    $output .= '<p><br/></p><h2>Prime Series of Matrix is Bi-directional</h2>';
  }

  if (!isset($reversed) && isset($forward)) {
    $direction = 'Forward Only';
    $output .= '<p><br/></p><h2>Prime Series of Matrix is Forward Only</h2>';
  }

  if (isset($reversed) && !isset($forward)) {
    $direction = 'Reversed Only';
    $spliced_matrix = $spliced_matrix_reversed;
    $output .= '<p><br/></p><h2>Prime Series of Matrix is Reversed Only</h2>';
  }

  if ($boolean == 'yes') {
    // And then we create the spliced matrix grid using wave indicators for coloring
    // (we could use the rows at this point as well)...
    $output .= '<div class="begintext endtable"></div><div class="begingrid"><h3>WAVE FORM POLE SHIFT: Highlighting the adjacent equal values.</h3><table class="table begingrid" cols="' . $tone * 2 . '" rows="' . $interval . '">';
    for ($i = 1; $i <= $interval; $i++) {
      $output .= '<tr>';
      $count = 1;
      foreach ($spliced_matrix as $spliced_row) {
        foreach ($spliced_row as $item) {
          if (!empty($item['row']) && $item['row'] == $i) {
            $prime = jellomatrix_primes($tone);
            if (($item['column']) % 2 == 0) {
              $item['color'] = 'green-text';
            }
            if (($item['column']) % 2 != 0) {
              $item['color'] = 'red-text';
            }
            if (isset($item['pole_shift'])) {
              if ($item['pole_shift'] == '1') {
                $item['background'] = 'yellow-background';
                $item['opacity'] = 1;
              }
              if ($item['pole_shift'] == '2') {
                $item['background'] = 'torquoise-background';
                $item['opacity'] = 1;
              }
            }

            $output .= '<td class="' . $item['column'] . 'x-' . $item['row'] . 'y ' . $item['color'] . ' tdgrid ' . $item['background'] . '" >' . $item['tone'] . '</td>';
            $count++;
          }
        }
      }
      $output .= '</tr>';
    }
    $output .= '</table><div class="begintext endtable"></div><hr class="hr"><br></div>';
  }
  //dpm($scaled);
  $output .= '<p><br/></p>' . $scaled . '<p><br/></p>';


  // And then we create the spliced matrix grid using wave indicators for coloring
  // (we could use the rows at this point as well)...
  $output_even = '<div class="begintext endtable"></div><div class="begingrid"><h3>WAVE FORM SCALES: The Waveform Scales: EVEN Rhythms</h3><table class="table begingrid" cols="' . $tone*2 . '" rows="' . $interval . '">';
  for ($i = 1; $i <= $interval; $i++) {
    $output_even .= '<tr>';
    $count = 1;
    foreach ($spliced_matrix as $spliced_row) {
      foreach ($spliced_row as $item) {
        if (!empty($item['row']) && $item['row'] == $i) {
          $prime = jellomatrix_primes($tone);
          if (($item['column'])%2 == 0) {
            $item['color'] = 'green-text';
          }
          if (($item['column'])%2 != 0) {
            $item['color'] = 'red-text';
          }
          if (isset($item['wave_limit'])) {
            if ($item['pole_shift'] == '2') {
              $item['background'] = 'yellow-background-light';
              $item['opacity'] = 1;
            }
            if ($item['pole_shift'] == '1') {
              $item['background'] = 'torquoise-background-light';
              $item['opacity'] = 1;
            }
          }
          $even = 0;
          if (isset($item['rhythm'])) {
            foreach ($item['rhythm'] as $rhythm) {
              if ($rhythm%2 == 0) {
                $even = 1;
                $evengrid = 1;
              }
            }
          }
          if (isset($item['yellow']) && isset($even) && $even == 1) {
            $item['background'] = $item['yellow'];
            $item['opacity'] = 1;
            $item['br'] = 'border-radius';
          }


          $output_even .= '<td class="' . $item['column'] . 'x-' . $item['row'] . 'y tdgrid ' . $item['background'];
          if (isset($item['br'])) {
            $output_even .= ' ' . $item['br'];
          }
          $output_even .= '" ';
          $output_even .= '><span style="background: ' . $item['background'] . ' !important;">';
          $output_even .= $item['tone'] . '</span></td>';

          $count++;

        }
      }
    }
    $output_even .= '</tr>';
  }
  $output_even .= '</table><div class="begintext endtable"></div><p></p><hr class="hr"></div>';

  if (isset($evengrid)) {
    $output .= $output_even;
    unset($evengrid);
  }

  // And then we create the spliced matric grid using wave indicators for coloring
  // (we could use the rows at this point as well)...
  $output_odd = '<div class="begintext endtable"></div><div class="begingrid"><h3>WAVE FORM SCALES: The Waveform Scales: ODD Rhythms</h3><table class="table begingrid" cols="' . $tone*2 . '" rows="' . $interval . '">';
  for ($i = 1; $i <= $interval; $i++) {
    $output_odd .= '<tr>';
    $count = 1;
    foreach ($spliced_matrix as $spliced_row) {
      foreach ($spliced_row as $item) {
        if (!empty($item['row']) && $item['row'] == $i) {
          $prime = jellomatrix_primes($tone);
          if (($item['column'])%2 == 0) {
            $item['color'] = 'green-text';
          }
          if (($item['column'])%2 != 0) {
            $item['color'] = 'red-text';
          }
          if (isset($item['wave_limit'])) {
            if ($item['pole_shift'] == '2') {
              $item['background'] = 'yellow-background-light';
              $item['opacity'] = 1;
            }
            if ($item['pole_shift'] == '1') {
              $item['background'] = 'torquoise-background-light';
              $item['opacity'] = 1;
            }
          }
          $odd = 0;
          if (isset($item['rhythm'])) {
            foreach ($item['rhythm'] as $rhythm) {
              if ($rhythm%2 != 0) {
                $odd = 1;
                $oddgrid = 1;
              }
            }
          }
          if (isset($item['yellow']) && isset($odd) && $odd != 0) {
            $item['background'] = $item['yellow'];
            $item['opacity'] = 1;
            $item['br'] = 'border-radius';
          }
          $output_odd .= '<td class="' . $item['column'] . 'x-' . $item['row'] . 'y tdgrid ' . $item['background'];
          if (isset($item['br'])) {
            $output_odd .= ' ' . $item['br'];
          }
          $output_odd .= '" ';
          $output_odd .= '><span>';
          $output_odd .= $item['tone'] . '</span></td>';

          $count++;
        }
      }
    }
    $output_odd .= '</tr>';
  }
  $output_odd .= '</table><div class="begintext endtable"></div><p></p><hr class="hr">';

  if (isset($oddgrid)) {
    $output .= $output_odd;
    unset($oddgrid);
  }
  // TODO: https://api.drupal.org/api/drupal/core%21modules%21views%21src%21Plugin%21views%21area%21Text.php/function/Text%3A%3Arender/8.7.x
  // return render($output);
  $outputt = [];
  $outputt = [
    '#type' => 'processed_text',
    '#text' => $output,
    '#format' => 'full_html',
  ];
  //return render($outputt);
  return $output;
}


// BOOKMARK: OUTPUT BLOCKS

function jellomatrix_output_splicegrid_scalepattern($scale_increments, $scaled, $primes, $tone, $interval) {
  $output = '';
  if (isset($scaled)) {
    $output .= '<div class="begintext"><p><h3>Scale Pattern:</h3></p>';
    //$output .= '<p>Whether you look at each row individually, or look at each diagonal row (in forward or backward \'slash\' ';
    //$output .= 'directions) you will notice that the order of numbers is consistent on every row (or each direction of diagonal rows) ';
    //$output .= 'and that only the starting number differs from row to row.  I refer to this as a \'scale\'.  If the scale were ';
    //$output .= 'to be played in a circle consisting of the numbers of the first \'tone\' value, the shape formed would be the ';
    //$output .= 'same regardless of which number you start with.';
    //$output .= '</p>';
    //$output .= '<p><img src="/sites/default/files/h_circle.png?t='. time().'" />';
    //$output .= '&nbsp;<img src="/sites/default/files/f_circle.png?t='. time().'" />';
    //$output .= '&nbsp;<img src="/sites/default/files/b_circle.png?t='. time().'" /></p><div class="endtext"><br></div>';
    //$output .= '<div class="begintext"><p><h3>Experimental Pattern:</h3></p><p><img src="/sites/default/files/circle_grid.png?t='. time().'" /></p><div class="endtext"><br></div>';
    //$output .= '<p><strong>' . $scaled . '...</strong></p><div class="endtext"><br></div>';
    $output .= '<p><strong>This tool is meant as a proof of concept and not as a complete set of waveforms that are possible (although I am working on it!).</strong></p><div class="endtext"><br></div>';
    $output .= '<p><strong>RED</strong> = Start of wave.</p>';
    $output .= '<p><strong>EVEN Waves</strong></p>';
    if (isset($scale_increments)) {
      foreach ($scale_increments as $i=>$increment) {
        $explode = explode(':', $increment);
        $t = $explode[0];
        $jump = $explode[1];
        $direction = $explode[2];
        $scale_direction = $explode[3];
        $color = $explode[4];
        if ($jump %2 == 0) {
          $output .= '<p><strong>Starting ' . $t . ':</strong> scale direction = ' . $scale_direction . ', rhythm = ' . $jump . ', initial vertical = ' . $direction . ', color = ' . $color . '.</p>';
        }
        if ($jump %2 != 0) {
          $odd_waves = 1;
        }
      }
    }
    if (isset($odd_waves)){
      $output .= '<p><strong>ODD Waves</strong></p>';
    }
    unset($odd_waves);
    if (isset($scale_increments)) {
      foreach ($scale_increments as $i=>$increment) {
        $explode = explode(':', $increment);
        $t = $explode[0];
        $jump = $explode[1];
        $direction = $explode[2];
        $scale_direction = $explode[3];
        $color = $explode[4];
        if ($jump %2 != 0) {
          $output .= '<p><strong>Starting ' . $t . ':</strong> scale direction = ' . $scale_direction . ', rhythm = ' . $jump . ', initial vertical = ' . $direction . ', color = ' . $color . '.</p>';
        }
      }
    }
  }
  $output .= '<p></p><br></div>';

  return $output;
}


// BOOKMARK: OUTPUT BLOCKS

function jellomatrix_output_splicegrid_harmonics($increment_original, $harmonics, $primes, $tone, $interval, $frequency, $print) {
  $notea_pairing = [];
  $noteb_pairing = [];
  $note_pairing = [];
  $note_assembly = [];
  $lambdoma_map = [];
  $output = '';
  $output .= '<div class="begintext"><p><a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png" /></a><br /><span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/InteractiveResource" property="dct:title" rel="dct:type">Jellomatrix</span> by <a xmlns:cc="http://creativecommons.org/ns#" href="https://www.jellobrain.com" property="cc:attributionName" rel="cc:attributionURL">Ana Willem</a> is licensed since 2007 under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License</a>.<br />Based on a work at <a xmlns:dct="http://purl.org/dc/terms/" href="https://www.jellobrain.com" rel="dct:source">https://www.jellobrain.com</a>.</p></div><hr class="hr">';
// First output the original harmonics with $columns and $rows.
  // Now output the differences between different integers.
  $output .= '<div class="endtable begintext"><h2>ODD/EVEN: Differences and Harmonics</h2>';
  $output .= '<p>These increment calculations show the relationships of the numbers in the grid by relating them to the ones in front of them (forward) and behind them (backwards) using the "tone" value as the base in the numbering system.</p><div class="endtext"><br></div>';
  $output .= '<p>The diagonal increments still go down the row, but show the relationships between the number and the one diagonally above (forward) it and below it (backward).</p><div class="endtext"><br></div>';
  $output .= '<p>The bold letters at the end of each row represent the Lambdona Notes that the ratios the repeating increments create.</p><div class="endtext"><br></div>';
  foreach($increment_original as $k=>$increment) {
    if ($k == 'row') {
      $r = '<h3>Row</h3>';
      foreach ($increment as $ke => $direction) {
        if ($ke == 'forward') {
          $r .= '<h4>Forward (Odd/Even) (x,y)|(x+1,y)</h4>';
          $r .= '<div class="begintext"><p>As alluded to above, if you look at the number grid below, what I have noticed is that I can usually find \'vortex activity\' starting and ending with rows that oscillate between \'0\' and another integer.  So in this section, the vortex arrays are between "zero" and "infinity". In addition, between these rows, it seems to be important to have the intervals mirror one another as you move towards the center.</p></div>';
          $count = 1;
          $r .= '<table class="table"><tr>';
          foreach ($direction as $row) {
            $r .= '<td class="tdgridltfirst">Row ' . $count . ': </td>';

            foreach ($row as $key => $item) {
              $test = $row;
              unset($clink); $clink = '';
              if (is_array($test)) {
                $a = array_pop($test);
                $b = array_pop($test);

                if (is_numeric($a) && ($a) % 2 == 0 && ($b) % 2 == 0) {
                  $clink = 'highlight';
                }
                elseif (is_numeric($a) && ($a) % 2 != 0 && ($b) % 2 != 0) {
                  $clink = 'highlight';
                }
              }
              if (isset($clink) && $clink == 'highlight') {
                $r .= '<td class="tdgrid highlight">' . $item . '</td>';
              }
              elseif (($item) % 2 == 0) {
                $r .= '<td class="tdgrid subhighlight">' . $item . '</td>';
              }
              elseif (($item) % 2 != 0) {
                $r .= '<td class="tdgrid">' . $item . '</td>';
              }
              if ($key == 0) {
                $zero = $item;
              }
              if ($key == 1) {
                $one = $item;
              }
              if ($key == 2) {
                $two = $item;
              }
              if ($key == 3) {
                $three = $item;
              }
              if ($key == 4) {
                $four = $item;
              }
              if ($key == 5) {
                $five = $item;
              }
              if ($key == 6) {
                $six = $item;
              }
              if ($key == 7) {
                $seven = $item;
              }
            }
            if (isset($two) && isset($zero) && $zero == $two) {
              $upper = $zero;
            } else {
              unset($upper);
            }
            if (isset($three) && $one == $three) {
              $lower = $one;
            } else {
              unset($lower);
            }

            if (isset($upper)) {

              foreach ($harmonics as $note) {
                $explode = explode(':', $note);
                //dpm($explode[3]);
                if (isset($lower) && $explode[0] == $upper && $explode[1] == $lower && !empty($explode[2])) {
                  $r .= '<td class="tdgrid"><strong>' . $explode[2] . '</strong></td>';
                  $note_order[] = $explode[3];
                  $lower = (int)$lower;
                  $upper = (int)$upper; $added = $upper+$lower;
                  if (is_numeric($upper) && is_numeric($lower)) {
                    $r .= '<td>' . $upper . '+' . $lower . '=<strong>' . $added . '</strong></td>';
                  }
                  $lambdoma_map[$k][$ke][$key][$count]['lower'] = $explode[0];
                  $lambdoma_map[$k][$ke][$key][$count]['upper'] = $explode[1];
                  $lambdoma_map[$k][$ke][$key][$count]['key'] = $explode[2];
                  if ($explode[2] == 'origin') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'black';
                  }
                  if ($explode[2] == 'C') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zcee';
                  }
                  elseif ($explode[2] == 'C#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zceesharp';
                  }
                  elseif ($explode[2] == 'D') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zdee';
                  }
                  elseif ($explode[2] == 'Eb') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zeeeflat';
                  }
                  elseif ($explode[2] == 'E') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zeee';
                  }
                  elseif ($explode[2] == 'F') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zeff';
                  }
                  elseif ($explode[2] == 'F#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zeffsharp';
                  }
                  elseif ($explode[2] == 'G') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zgee';
                  }
                  elseif ($explode[2] == 'G#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zgeesharp';
                  }
                  elseif ($explode[2] == 'A') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zay';
                  }
                  elseif ($explode[2] == 'Bb') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zbeeflat';
                  }
                  elseif ($explode[2] == 'B') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zbee';
                  }
                  else {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'darkslategray';
                  }
                  if (isset($explode[3])) {
                    $lambdoma_map[$k][$ke][$key][$count]['frequency'] = $explode[3];
                  }
                }
              }
            }
            $r .= '</tr>';
            $count++;
          }
          $r .= '</table>';
          $r .= '<h3>Order of frequencies: based on a ' . $frequency . 'Hz baseline or "C"</h3><ol>';
          if (isset($note_order)) {
            foreach ($note_order as $key => $hz) {

              $r .= '<li>' . $hz . 'Hz</li>';
            }
          }
          $r .= '</ol><hr>';
          $r .= '<div class="endtext"><br></div>';
          if (isset($note_order)) {
            $note_assembly[$ke]['r'][] = $note_order;
          }
        }
        if ($ke == 'backward') {
          unset($note_order);
          $rd = '<h4>Backward (Odd/Even) (x,y)|(x-1,y)</h4>';
          $count = 1;
          $rd .= '<table class="table"><tr>';
          foreach ($direction as $row) {
            $rd .= '<td class="tdgridltfirst">Row ' . $count . ': </td>';

            foreach ($row as $key => $item) {
              $test = $row;
              unset($clink); $clink = '';
              if (is_array($test)) {
                $a = array_pop($test);
                $b = array_pop($test);

                if (is_numeric($a) && ($a) % 2 == 0 && ($b) % 2 == 0) {
                  $clink = 'highlight';
                }
                elseif (is_numeric($a) && ($a) % 2 != 0 && ($b) % 2 != 0) {
                  $clink = 'highlight';
                }
              }
              if (isset($clink) && $clink == 'highlight') {
                $rd .= '<td class="tdgrid highlight">' . $item . '</td>';
              }
              elseif (($item) % 2 == 0) {
                $rd .= '<td class="tdgrid subhighlight">' . $item . '</td>';
              }
              elseif (($item) % 2 != 0) {
                $rd .= '<td class="tdgrid">' . $item . '</td>';
              }
              if ($key == 0) {
                $zero = $item;
              }
              if ($key == 1) {
                $one = $item;
              }
              if ($key == 2) {
                $two = $item;
              }
              if ($key == 3) {
                $three = $item;
              }
            }
            if (isset($two) && isset($zero) && $zero == $two) {
              $upper = $zero;
            } else {
              unset($upper);
            }
            if (isset($three) && $one == $three) {
              $lower = $one;
            } else {
              unset($lower);
            }

            if (isset($upper)) {

              foreach ($harmonics as $note) {
                $explode = explode(':', $note);
                if (isset($lower) && $explode[0] == $upper && $explode[1] == $lower && !empty($explode[2])) {
                  $rd .= '<td class="tdgrid"><strong>' . $explode[2] . '</strong></td>';
                  $note_order[]= $explode[3];
                  $lower = (int)$lower;
                  $upper = (int)$upper; $added = $upper+$lower;
                  if (is_numeric($upper) && is_numeric($lower)) {
                    $rd .= '<td>' . $upper . '+' . $lower . '=<strong>' . $added . '</strong></td>';
                  }
                  $lambdoma_map[$k][$ke][$key][$count]['lower'] = $explode[0];
                  $lambdoma_map[$k][$ke][$key][$count]['upper'] = $explode[1];
                  $lambdoma_map[$k][$ke][$key][$count]['key'] = $explode[2];
                  if ($explode[2] == 'origin') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'black';
                  }
                  if ($explode[2] == 'C') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'cee';
                  }
                  elseif ($explode[2] == 'C#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'ceesharp';
                  }
                  elseif ($explode[2] == 'D') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'dee';
                  }
                  elseif ($explode[2] == 'Eb') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'eeeflat';
                  }
                  elseif ($explode[2] == 'E') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'eee';
                  }
                  elseif ($explode[2] == 'F') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'eff';
                  }
                  elseif ($explode[2] == 'F#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'effsharp';
                  }
                  elseif ($explode[2] == 'G') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'gee';
                  }
                  elseif ($explode[2] == 'G#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'geesharp';
                  }
                  elseif ($explode[2] == 'A') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'ay';
                  }
                  elseif ($explode[2] == 'Bb') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'beeflat';
                  }
                  elseif ($explode[2] == 'B') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'bee';
                  }
                  else {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'darkslategray';
                  }
                  if (isset($explode[3])) {
                    $lambdoma_map[$k][$ke][$key][$count]['frequency'] = $explode[3];
                  }
                }
              }
            }
            $rd .= '</tr>';
            $count++;
          }
          $rd .= '</table>';
          $rd .= '<h3>Order of frequencies: based on a ' . $frequency . 'Hz baseline or "C"</h3><ol>';
          if (isset($note_order)) {
            foreach ($note_order as $key => $hz) {

              $rd .= '<li>' . $hz . 'Hz</li>';
            }
          }
          $rd .= '</ol><hr>';
          $rd .= '<div class="endtext"><br></div>';
          if (isset($note_order)) {
            $note_assembly[$ke]['rd'][] = $note_order;
          }
        }
      }
    }
    if ($k == 'lrdiag') {
      $lr = '<h3>Left to Right Diagonals across a Row</h3>';
      foreach ($increment as $ke=>$direction) {
        if ($ke == 'forward') {
          unset($note_order);
          $lr .= '<h4>Forward (Odd/Even) (x,y)|(x+1,y+1)</h4>';
          $count = 1;
          $lr .= '<table class="table"><tr>';
          foreach ($direction as $row) {
            $lr .= '<td class="tdgridlt">LR Row ' . $count .': </td>';
            foreach ($row as $key=>$item) {
              $test = $row;
              unset($clink); $clink = '';
              if (is_array($test)) {
                $a = array_pop($test);
                $b = array_pop($test);

                if (is_numeric($a) && ($a) % 2 == 0 && ($b) % 2 == 0) {
                  $clink = 'highlight';
                }
                elseif (is_numeric($a) && ($a) % 2 != 0 && ($b) % 2 != 0) {
                  $clink = 'highlight';
                }
              }
              if (isset($clink) && $clink == 'highlight') {
                $lr .= '<td class="tdgrid highlight">' . $item . '</td>';
              }
              elseif (($item) % 2 == 0) {
                $lr .= '<td class="tdgrid subhighlight">' . $item . '</td>';
              }
              elseif (($item) % 2 != 0) {
                $lr .= '<td class="tdgrid">' . $item . '</td>';
              }
              if ($key == 0) {
                $zero = $item;
              }
              if ($key == 1) {
                $one = $item;
              }
              if ($key == 2) {
                $two = $item;
              }
              if ($key == 3) {
                $three = $item;
              }
            }
            if (isset($two) && isset($zero) && $zero == $two) {
              $upper = $zero;
            }
            else {
              unset($upper);
            }
            if (isset($three) && $one == $three) {
              $lower = $one;
            }
            else {
              unset($lower);
            }

            if (isset($upper)) {

              foreach ($harmonics as $note) {
                $explode = explode(':', $note);
                if (isset($lower) && $explode[0] == $upper && $explode[1] == $lower && !empty($explode[2])) {
                  $lr .= '<td class="tdgrid"><strong>' . $explode[2] . '</strong></td>';
                  $note_order[]= $explode[3];
                  $lower = (int)$lower;
                  $upper = (int)$upper; $added = $upper+$lower;
                  if (is_numeric($upper) && is_numeric($lower)) {
                    $lr .= '<td>' . $upper . '+' . $lower . '=<strong>' . $added . '</strong></td>';
                  }
                  $lambdoma_map[$k][$ke][$key][$count]['lower'] = $explode[0];
                  $lambdoma_map[$k][$ke][$key][$count]['upper'] = $explode[1];
                  $lambdoma_map[$k][$ke][$key][$count]['key'] = $explode[2];
                  if ($explode[2] == 'origin') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'black';
                  }
                  if ($explode[2] == 'C') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zcee';
                  }
                  elseif ($explode[2] == 'C#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zceesharp';
                  }
                  elseif ($explode[2] == 'D') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zdee';
                  }
                  elseif ($explode[2] == 'Eb') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zeeeflat';
                  }
                  elseif ($explode[2] == 'E') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zeee';
                  }
                  elseif ($explode[2] == 'F') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zeff';
                  }
                  elseif ($explode[2] == 'F#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zeffsharp';
                  }
                  elseif ($explode[2] == 'G') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zgee';
                  }
                  elseif ($explode[2] == 'G#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zgeesharp';
                  }
                  elseif ($explode[2] == 'A') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zay';
                  }
                  elseif ($explode[2] == 'Bb') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zbeeflat';
                  }
                  elseif ($explode[2] == 'B') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zbee';
                  }
                  else {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'darkslategray';
                  }
                  if (isset($explode[3])) {
                    $lambdoma_map[$k][$ke][$key][$count]['frequency'] = $explode[3];
                  }
                }
              }
            }
            $lr .= '</tr>';
            $count++;
          }
          $lr .= '</table>';
          $lr .= '<h3>Order of frequencies: based on a ' . $frequency . 'Hz baseline or "C"</h3><ol>';
          if (isset($note_order)) {
            foreach ($note_order as $key => $hz) {

              $lr .= '<li>' . $hz . 'Hz</li>';
            }
          }
          $lr .= '</ol><hr>';
          $lr .= '<div class="endtext"><br></div>';
          if (isset($note_order)) {
            $note_assembly[$ke]['lr'][] = $note_order;
          }
        }
        if ($ke == 'backward') {
          unset($note_order);
          $lrd = '<h4>Backward (Odd/Even) (x,y)|(x-1,y-1)</h4>';
          $count = 1;
          $lrd .= '<table class="table"><tr>';
          foreach ($direction as $row) {
            $lrd .= '<td class="tdgridlt">LR Row ' . $count .': </td>';
            foreach ($row as $key=>$item) {
              $test = $row;
              unset($clink); $clink = '';
              if (is_array($test)) {
                $a = array_pop($test);
                $b = array_pop($test);

                if (is_numeric($a) && ($a) % 2 == 0 && ($b) % 2 == 0) {
                  $clink = 'highlight';
                }
                elseif (is_numeric($a) && ($a) % 2 != 0 && ($b) % 2 != 0) {
                  $clink = 'highlight';
                }
              }
              if (isset($clink) && $clink == 'highlight') {
                $lrd .= '<td class="tdgrid highlight">' . $item . '</td>';
              }
              elseif (($item) % 2 == 0) {
                $lrd .= '<td class="tdgrid subhighlight">' . $item . '</td>';
              }
              elseif (($item) % 2 != 0) {
                $lrd .= '<td class="tdgrid">' . $item . '</td>';
              }
              if ($key == 0) {
                $zero = $item;
              }
              if ($key == 1) {
                $one = $item;
              }
              if ($key == 2) {
                $two = $item;
              }
              if ($key == 3) {
                $three = $item;
              }
            }
            if (isset($two) && isset($zero) && $zero == $two) {
              $upper = $zero;
            }
            else {
              unset($upper);
            }
            if (isset($three) && $one == $three) {
              $lower = $one;
            }
            else {
              unset($lower);
            }

            if (isset($upper)) {

              foreach ($harmonics as $note) {
                $explode = explode(':', $note);
                if (isset($lower) && $explode[0] == $upper && $explode[1] == $lower && !empty($explode[2])) {
                  $lrd .= '<td class="tdgrid"><strong>' . $explode[2] . '</strong></td>';
                  $note_order[]= $explode[3];
                  $lower = (int)$lower;
                  $upper = (int)$upper; $added = $upper+$lower;
                  if (is_numeric($upper) && is_numeric($lower)) {
                    $lrd .= '<td>' . $upper . '+' . $lower . '=<strong>' . $added . '</strong></td>';
                  }
                  $lambdoma_map[$k][$ke][$key][$count]['lower'] = $explode[0];
                  $lambdoma_map[$k][$ke][$key][$count]['upper'] = $explode[1];
                  $lambdoma_map[$k][$ke][$key][$count]['key'] = $explode[2];
                  if ($explode[2] == 'origin') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'black';
                  }
                  if ($explode[2] == 'C') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'cee';
                  }
                  elseif ($explode[2] == 'C#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'ceesharp';
                  }
                  elseif ($explode[2] == 'D') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'dee';
                  }
                  elseif ($explode[2] == 'Eb') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'eeeflat';
                  }
                  elseif ($explode[2] == 'E') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'eee';
                  }
                  elseif ($explode[2] == 'F') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'eff';
                  }
                  elseif ($explode[2] == 'F#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'effsharp';
                  }
                  elseif ($explode[2] == 'G') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'gee';
                  }
                  elseif ($explode[2] == 'G#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'geesharp';
                  }
                  elseif ($explode[2] == 'A') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'ay';
                  }
                  elseif ($explode[2] == 'Bb') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'beeflat';
                  }
                  elseif ($explode[2] == 'B') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'bee';
                  }
                  else {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'darkslategray';
                  }
                  if (isset($explode[3])) {
                    $lambdoma_map[$k][$ke][$key][$count]['frequency'] = $explode[3];
                  }
                }
              }
            }
            $lrd .= '</tr>';
            $count++;
          }
          $lrd .= '</table>';
          $lrd .= '<h3>Order of frequencies: based on a ' . $frequency . 'Hz baseline or "C"</h3><ol>';
          if (isset($note_order)) {
            foreach ($note_order as $key => $hz) {

              $lrd .= '<li>' . $hz . 'Hz</li>';
            }
          }
          $lrd .= '</ol><hr>';
          $lrd .= '<div class="endtext"><br></div>';
          if (isset($note_order)) {
           $note_assembly[$ke]['lrd'][] = $note_order;
          }
        }
      }
    }
    if ($k == 'rldiag') {
      $rl = '<h3>Right to Left Diagonals across a Row</h3>';
      foreach ($increment as $ke=>$direction) {
        if ($ke == 'forward') {
          unset($note_order);
          $rl .= '<h4>Forward (Odd/Even) (x,y)|(x+1,y-1)</h4>';
          $count = 1;
          $rl .= '<table class="table"><tr>';
          foreach ($direction as $row) {
            $rl .= '<td class="tdgridlt">RL Row ' . $count .': </td>';
            foreach ($row as $key=>$item) {
              $test = $row;
              unset($clink); $clink = '';
              if (is_array($test)) {
                $a = array_pop($test);
                $b = array_pop($test);

                if (is_numeric($a) && ($a) % 2 == 0 && ($b) % 2 == 0) {
                  $clink = 'highlight';
                }
                elseif (is_numeric($a) && ($a) % 2 != 0 && ($b) % 2 != 0) {
                  $clink = 'highlight';
                }
              }
              if (isset($clink) && $clink == 'highlight') {
                $rl .= '<td class="tdgrid highlight">' . $item . '</td>';
              }
              elseif (($item) % 2 == 0) {
                $rl .= '<td class="tdgrid subhighlight">' . $item . '</td>';
              }
              elseif (($item) % 2 != 0) {
                $rl .= '<td class="tdgrid">' . $item . '</td>';
              }
              if ($key == 0) {
                $zero = $item;
              }
              if ($key == 1) {
                $one = $item;
              }
              if ($key == 2) {
                $two = $item;
              }
              if ($key == 3) {
                $three = $item;
              }
            }
            if (isset($two) && isset($zero) && $zero == $two) {
              $upper = $zero;
            }
            else {
              unset($upper);
            }
            if (isset($three) && $one == $three) {
              $lower = $one;
            }
            else {
              unset($lower);
            }

            if (isset($upper)) {

              foreach ($harmonics as $note) {
                $explode = explode(':', $note);
                if (isset($lower) && $explode[0] == $upper && $explode[1] == $lower && !empty($explode[2])) {
                  $rl .= '<td class="tdgrid"><strong>' . $explode[2] . '</strong></td>';
                  $note_order[]= $explode[3];
                  $lower = (int)$lower;
                  $upper = (int)$upper; $added = $upper+$lower;
                  if (is_numeric($upper) && is_numeric($lower)) {
                    $rl .= '<td>' . $upper . '+' . $lower . '=<strong>' . $added . '</strong></td>';
                  }
                  $lambdoma_map[$k][$ke][$key][$count]['lower'] = $explode[0];
                  $lambdoma_map[$k][$ke][$key][$count]['upper'] = $explode[1];
                  $lambdoma_map[$k][$ke][$key][$count]['key'] = $explode[2];
                  if ($explode[2] == 'origin') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'black';
                  }
                  if ($explode[2] == 'C') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zcee';
                  }
                  elseif ($explode[2] == 'C#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zceesharp';
                  }
                  elseif ($explode[2] == 'D') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zdee';
                  }
                  elseif ($explode[2] == 'Eb') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zeeeflat';
                  }
                  elseif ($explode[2] == 'E') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zeee';
                  }
                  elseif ($explode[2] == 'F') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zeff';
                  }
                  elseif ($explode[2] == 'F#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zeffsharp';
                  }
                  elseif ($explode[2] == 'G') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zgee';
                  }
                  elseif ($explode[2] == 'G#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zgeesharp';
                  }
                  elseif ($explode[2] == 'A') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zay';
                  }
                  elseif ($explode[2] == 'Bb') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zbeeflat';
                  }
                  elseif ($explode[2] == 'B') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zbee';
                  }
                  else {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'darkslategray';
                  }
                  if (isset($explode[3])) {
                    $lambdoma_map[$k][$ke][$key][$count]['frequency'] = $explode[3];
                  }
                }
              }
            }
            $rl .= '</tr>';
            $count++;
          }
          $rl .= '</table>';
          $rl .= '<h3>Order of frequencies: based on a ' . $frequency . 'Hz baseline or "C"</h3><ol>';
          if (isset($note_order)) {
            foreach ($note_order as $key => $hz) {

              $rl .= '<li>' . $hz . 'Hz</li>';
            }
          }
          $rl .= '</ol><hr>';
          $rl .= '<div class="endtext"><br></div>';
          if (isset($note_order)) {
            $note_assembly[$ke]['rl'][] = $note_order;
          }
        }
        if ($ke == 'backward') {
          unset($note_order);
          $rld = '<h4>Backward (Odd/Even) (x,y)|(x-1,y+1)</h4>';
          $count = 1;
          $rld .= '<table class="table"><tr>';
          foreach ($direction as $row) {
            $rld .= '<td class="tdgridlt">RL Row ' . $count .': </td>';
            foreach ($row as $key=>$item) {
              $test = $row;
              unset($clink); $clink = ''; $clink = '';
              if (is_array($test)) {
                $a = array_pop($test);
                $b = array_pop($test);

                if (is_numeric($a) && ($a) % 2 == 0 && ($b) % 2 == 0) {
                  $clink = 'highlight';
                }
                elseif (is_numeric($a) && ($a) % 2 != 0 && ($b) % 2 != 0) {
                  $clink = 'highlight';
                }
              }
              if (isset($clink) && $clink == 'highlight') {
                $rld .= '<td class="tdgrid highlight">' . $item . '</td>';
              }
              elseif (($item) % 2 == 0) {
                $rld .= '<td class="tdgrid subhighlight">' . $item . '</td>';
              }
              elseif (($item) % 2 != 0) {
                $rld .= '<td class="tdgrid">' . $item . '</td>';
              }
              if ($key == 0) {
                $zero = $item;
              }
              if ($key == 1) {
                $one = $item;
              }
              if ($key == 2) {
                $two = $item;
              }
              if ($key == 3) {
                $three = $item;
              }
            }
            if (isset($two) && isset($zero) && $zero == $two) {
              $upper = $zero;
            }
            else {
              unset($upper);
            }
            if (isset($three) && $one == $three) {
              $lower = $one;
            }
            else {
              unset($lower);
            }

            if (isset($upper)) {

              foreach ($harmonics as $note) {
                $explode = explode(':', $note);
                if (isset($lower) && $explode[0] == $upper && $explode[1] == $lower && !empty($explode[2])) {
                  $rld .= '<td class="tdgrid"><strong>' . $explode[2] . '</strong></td>';
                  $note_order[]= $explode[3];
                  $lower = (int)$lower;
                  $upper = (int)$upper; $added = $upper+$lower;
                  if (is_numeric($upper) && is_numeric($lower)) {
                    $rld .= '<td>' . $upper . '+' . $lower . '=<strong>' . $added . '</strong></td>';
                  }
                  $lambdoma_map[$k][$ke][$key][$count]['lower'] = $explode[0];
                  $lambdoma_map[$k][$ke][$key][$count]['upper'] = $explode[1];
                  $lambdoma_map[$k][$ke][$key][$count]['key'] = $explode[2];
                  if ($explode[2] == 'origin') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'black';
                  }
                  if ($explode[2] == 'C') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'cee';
                  }
                  elseif ($explode[2] == 'C#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'ceesharp';
                  }
                  elseif ($explode[2] == 'D') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'dee';
                  }
                  elseif ($explode[2] == 'Eb') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'eeeflat';
                  }
                  elseif ($explode[2] == 'E') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'eee';
                  }
                  elseif ($explode[2] == 'F') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'eff';
                  }
                  elseif ($explode[2] == 'F#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'effsharp';
                  }
                  elseif ($explode[2] == 'G') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'gee';
                  }
                  elseif ($explode[2] == 'G#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'geesharp';
                  }
                  elseif ($explode[2] == 'A') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'ay';
                  }
                  elseif ($explode[2] == 'Bb') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'beeflat';
                  }
                  elseif ($explode[2] == 'B') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'bee';
                  }
                  else {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'darkslategray';
                  }
                  if (isset($explode[3])) {
                    $lambdoma_map[$k][$ke][$key][$count]['frequency'] = $explode[3];
                  }
                }
              }
            }
            $rld .= '</tr>';
            $count++;
          }
          $rld .= '</table>';
          $rld .= '<h3>Order of frequencies: based on a ' . $frequency . 'Hz baseline or "C"</h3><ol>';
          if (isset($note_order)) {
            foreach ($note_order as $key => $hz) {

              $rld .= '<li>' . $hz . 'Hz</li>';
            }
          }
          $rld .= '</ol><hr>';
          $rld .= '<div class="endtext"><br></div>';
          if (isset($note_order)) {
            $note_assembly[$ke]['rld'][] = $note_order;
          }
        }
      }
    }
  }

  /*$output .= '<table><tr><th>k</th><th>ke</th><th>key</th><th>row</th><th>note</th><th>lower</th><th>upper</th></tr>';
  foreach($lambdoma_map as $k => $data) {
    foreach($data as $ke => $stuff) {
      foreach ($stuff as $key => $counts) {
        foreach ($counts as $count => $values) {
          $output .= "<tr><td>" . $k . "</td><td>" . $ke . "</td><td>" . $key . "</td><td>" . $count . "</td><td>" . $values['key'] . "</td><td>" . $values['lower'] . "</td><td>" . $values['upper'] . "</td></tr>";
        }
      }
    }
  }
  $output .= "</table>";*/

  $map = [];
  foreach ($lambdoma_map as $k => $data) {
    foreach ($data as $ke => $stuff) {
      //if ($ke = 'forward' || $k = 'row') {*/
      foreach ($stuff as $key => $counts) {
        foreach ($counts as $count => $values) {
          //dpm($values);
          for ($u = 0; $u <= 16; $u++) {
            for ($l = 0; $l <= 16; $l++) {
              if (!in_array($values['upper'] . ':' . $values['lower'] . ':' . $values['class'] . ':' . $values['frequency'] . ':' . $values['key'], $map)) {
                $map[] = $values['upper'] . ':' . $values['lower'] . ':' . $values['class'] . ':' . $values['frequency'] . ':' . $values['key'];
              }
            }
          }
        }
      }
      //}
    }
  }



  $output .= $r;
  $output .= $rd;


  $output .= '<h3>Lambdoma Keyboard (<a href="http://lambdoma.com" target="_blank">Barbara Hero</a>) colored in with the locally determined frequency , and the letter note values based on a 256Hz C.</h3><table><tr><th></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th><th>16</th></tr>';
  for ($u=0; $u<=16; $u++) {
    $output .= '<tr>';
    $output .= '<td>' . $u . '</td>';


    for ($l = 0; $l <= 16; $l++) {
      $class = 'white';
      foreach ($map as $n => $unexploded) {
        $exploded = explode(':', $unexploded);
        if ($exploded[0] == $l && $exploded[1] == $u && !empty($explode[2])) {
          $np = 'b' . $n;
          if ($n >= $tone ) {
            $np = $n - $tone;
            $np = 'f' . $np;
          }
          $class = $exploded[2];
          $freq = $exploded[3];
          $kay = $exploded[4] . ':' . $np;
          //$output .= '<td>' . $u . '</td>';
        }
        if ($class == 'white') {
          if ($l == 0) {
            $class = 'lightgray';
          }
          elseif ($u == 0) {
            $class = 'lightgray';
          }
        }
      }
      $output .= '<td class ="' . $class . '">' . $u . '/' . $l . '<br>';
      if (isset($freq) && $freq != 'INF' && $class != 'white' && $class != 'lightgray') {
        $output .= intval($freq) . 'Hz<br>' . $kay . '</td>';
      }
      elseif (isset($freq) && $freq == 'INF') {
        $output .= 'INF</td>';
      }
      else {
        $output .= '-<br>-</td>';
      }
    }
    $output .= '</tr>';
  }
  $output .= '</table>';

  $output .= $rl;
  $output .= $rld;


  $output .= '<h3>Lambdoma Keyboard (<a href="http://lambdoma.com" target="_blank">Barbara Hero</a>) colored in with the locally determined frequency , and the letter note values based on a 256Hz C.</h3><table><tr><th></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th><th>16</th></tr>';
  for ($u=0; $u<=16; $u++) {
    $output .= '<tr>';
    $output .= '<td>' . $u . '</td>';

    for ($l = 0; $l <= 16; $l++) {
      $class = 'white';
      foreach ($map as $n => $unexploded) {
        $exploded = explode(':', $unexploded);
        if ($exploded[0] == $l && $exploded[1] == $u && !empty($explode[2])) {
          $np = 'b' . $n;
          if ($n >= $tone ) {
            $np = $n - $tone;
            $np = 'f' . $np;
          }
          $class = $exploded[2];
          $freq = $exploded[3];
          $kay = $exploded[4] . ':' . $np;
          //$output .= '<td>' . $u . '</td>';
        }
        if ($class == 'white') {
          if ($l == 0) {
            $class = 'lightgray';
          }
          elseif ($u == 0) {
            $class = 'lightgray';
          }
        }
      }
      $output .= '<td class ="' . $class . '">' . $u . '/' . $l . '<br>';
      if (isset($freq) && $freq != 'INF' && $class != 'white' && $class != 'lightgray') {
        $output .= intval($freq) . 'Hz<br>' . $kay . '</td>';
      }
      elseif (isset($freq) && $freq == 'INF') {
        $output .= 'INF</td>';
      }
      else {
        $output .= '-<br>-</td>';
      }
    }
    $output .= '</tr>';
  }
  $output .= '</table>';
  $output .= $lr;
  $output .= $lrd;


  $output .= '<h3>Lambdoma Keyboard (<a href="http://lambdoma.com" target="_blank">Barbara Hero</a>) colored in with the locally determined frequency , and the letter note values based on a 256Hz C.</h3><table><tr><th></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th><th>16</th></tr>';
  for ($u=0; $u<=16; $u++) {
    $output .= '<tr>';
    $output .= '<td>' . $u . '</td>';


    for ($l = 0; $l <= 16; $l++) {
      $class = 'white';
      foreach ($map as $n => $unexploded) {
        $exploded = explode(':', $unexploded);
        if ($exploded[0] == $l && $exploded[1] == $u && !empty($explode[2])) {
          $np = 'b' . $n;
          if ($n >= $tone ) {
            $np = $n - $tone;
            $np = 'f' . $np;
          }
          $class = $exploded[2];
          $freq = $exploded[3];
          $kay = $exploded[4] . ':' . $np;

          //$output .= '<td>' . $u . '</td>';
        }
        if ($class == 'white') {
          if ($l == 0) {
            $class = 'lightgray';
          }
          elseif ($u == 0) {
            $class = 'lightgray';
          }
        }
      }
      $output .= '<td class ="' . $class . '">' . $u . '/' . $l . '<br>';
      if (isset($freq) && $freq != 'INF' && $class != 'white' && $class != 'lightgray') {
        $output .= intval($freq) . 'Hz<br>' . $kay . '</td>';
      }
      elseif (isset($freq) && $freq == 'INF') {
        $output .= 'INF</td>';
      }
      else {
        $output .= '-<br>-</td>';
      }
    }
    $output .= '</tr>';
  }
  $output .= '</table>';

  $output .= '<hr class="hr">';

  //dpm($note_assembly);
  if (isset($note_assembly['forward']['r']) && !empty($note_assembly['forward']['r'][0])) {
    $array_size  = count($note_assembly['forward']['r']);
    //dpm($array_size);
    for ($i= 0; $i<$array_size; $i++) {
      $note_assembly['pairings']['horizontal'][] = $note_assembly['forward']['r'][$i];
    }
  }
  if (isset($note_assembly['backward']['rd']) && !empty($note_assembly['backward']['rd'][0])) {
    $array_size  = count($note_assembly['backward']['rd']);
    //dpm($array_size);
    for ($i= 0; $i<$array_size; $i++) {
      $note_assembly['pairings']['horizontal'][] = $note_assembly['backward']['rd'][$i];
    }
  }
  if (isset($note_assembly['forward']['lr']) && !empty($note_assembly['forward']['lr'][0])) {
    $array_size  = count($note_assembly['forward']['lr']);
    //dpm($array_size);
    for ($i= 0; $i<$array_size; $i++) {
      $note_assembly['pairings']['forwardslash'][] = $note_assembly['forward']['lr'][$i];
    }
  }
  if (isset($note_assembly['backward']['lrd']) && !empty($note_assembly['backward']['lrd'][0])) {
    $array_size  = count($note_assembly['backward']['lrd']);
    //dpm($array_size);
    for ($i= 0; $i<$array_size; $i++) {
      $note_assembly['pairings']['backslash'][] = $note_assembly['backward']['lrd'][$i];
    }
  }
  if (isset($note_assembly['forward']['rl']) && !empty($note_assembly['forward']['rl'][0])) {
    $array_size  = count($note_assembly['forward']['rl']);
    //dpm($array_size);
    for ($i= 0; $i<$array_size; $i++) {
      $note_assembly['pairings']['forwardslash'][] = $note_assembly['forward']['rl'][$i];
    }
  }
  if (isset($note_assembly['backward']['lrd']) && !empty($note_assembly['backward']['lrd'][0])) {
    $array_size  = count($note_assembly['backward']['lrd']);
    //dpm($array_size);
    for ($i= 0; $i<$array_size; $i++) {
      $note_assembly['pairings']['backslash'][] = $note_assembly['backward']['lrd'][$i];
    }
  }

  if (isset($note_assembly['forward']['lr']) && !empty($note_assembly['forward']['lr'][0])) {
    $array_size  = count($note_assembly['forward']['lr']);
    for ($i= 0; $i<$array_size; $i++) {
      $note_assembly['complete']['complete'][] = $note_assembly['forward']['lr'][$i];
    }
  }
  if (isset($note_assembly['forward']['r']) && !empty($note_assembly['forward']['r'][0])) {
    $array_size  = count($note_assembly['forward']['r']);
    for ($i= 0; $i<$array_size; $i++) {
      $note_assembly['complete']['complete'][] = $note_assembly['forward']['r'][$i];
    }
  }
  if (isset($note_assembly['forward']['rl']) && !empty($note_assembly['forward']['rl'][0])) {
    $array_size  = count($note_assembly['forward']['rl']);
    for ($i= 0; $i<$array_size; $i++) {
      $note_assembly['complete']['complete'][] = $note_assembly['forward']['rl'][$i];
    }
  }
  if (isset($note_assembly['backward']['lrd']) && !empty($note_assembly['backward']['lrd'][0])) {
    $array_size  = count($note_assembly['backward']['lrd']);
    for ($i= 0; $i<$array_size; $i++) {
      $note_assembly['complete']['complete'][] = $note_assembly['backward']['lrd'][$i];
    }
  }
  if (isset($note_assembly['backward']['rd']) && !empty($note_assembly['backward']['rd'][0])) {
    $array_size  = count($note_assembly['backward']['rd']);
    for ($i= 0; $i<$array_size; $i++) {
      $note_assembly['complete']['complete'][] = $note_assembly['backward']['rd'][$i];
    }
  }
  if (isset($note_assembly['backward']['rld']) && !empty($note_assembly['backward']['rld'][0])) {
    $array_size  = count($note_assembly['backward']['rld']);
    for ($i= 0; $i<$array_size; $i++) {
      $note_assembly['complete']['complete'][] = $note_assembly['backward']['rld'][$i];
    }
  }

  if (!empty($note_assembly)) {
    if (isset($print) && $print != 'none') {
      jellomatrix_generate_sound_files($note_assembly, $tone, $interval, $frequency, $print);
    }
  }

  return $output;
}


// BOOKMARK: OUTPUT BLOCKS

function jellomatrix_generate_sound_files($note_assembly, $tone, $interval, $frequency, $print) {
  //var_dump(debug_backtrace());
  $prints_array = [];
  $print_array =[];
  if($print == 1) {
    $print_array['forward'] = $note_assembly['forward'];
    $print_array['backward'] = $note_assembly['backward'];
  }
  if($print == 2) {
    $prints_array['pairings'] = $note_assembly['pairings'];
    /*
     * JOINWAVS
     */
    //$print_array['forward'] = $note_assembly['forward'];
    //$print_array['backward'] = $note_assembly['backward'];
  }
  if($print == 3) {
    //$prints_array['complete'] = $note_assembly['complete'];
    /*
     * JOINWAVS
     */
    $print_array['forward'] = $note_assembly['forward'];
    $print_array['backward'] = $note_assembly['backward'];
  }
  //dpm($prints_array);

  if (!empty($prints_array)) {
    foreach ($prints_array as $ke => $directions) {
      if (isset($ke) && $ke == 'pairings') {
        foreach ($directions as $direction => $collection) {
          foreach ($collection as $pos => $freqs) {
            if ($pos != 0) {
              foreach ($freqs as $position => $freaq) {
                $print_array[$ke][$direction][$pos][$position][0][] = (int) $prints_array[$ke][$direction][0][$position];
                $print_array[$ke][$direction][$pos][$position][0][] = (int) $freaq;
              }
            }
          }
        }
      }
      if (isset($ke) && $ke == 'complete') {
        foreach ($directions as $direction => $collection) {
          foreach ($collection as $pos => $freqs) {
            if ($pos == 0) {
              foreach ($freqs as $position => $freaq) {
                $print_array[$ke][$direction][$pos][$position][0][] = (int) $prints_array[$ke][$direction][0][$position];
              }
            }
            if ($pos > 0) {
              foreach ($freqs as $position => $freaq) {
                $print_array[$ke][$direction][0][$position][0][] = (int) $freaq;
              }
            }
          }
        }
      }
    }
  }
  if(!empty($print_array)) {
    foreach ($print_array as $ke => $directions) {

      //Calculate variable dependent fields
      if ($ke == 'pairings') {
        $channels = 2; //Stereo
      }
      elseif ($ke == 'complete') {
        $channels = 6; //Mono
      }
      elseif ($ke == 'forward' || $ke == 'backward') {
        $channels = 1; //Mono
      }

      //$channels = 1;

      if (isset($directions)) {
        foreach ($directions as $direction => $collection) {

          if ($channels == 1) {

            foreach ($collection as $freqs) {

              //Path to output file
              $filePath = 'sites/default/files/' . $ke . $tone . '_' . $interval . $direction . $frequency . '.wav';

              //Open a handle to our file in write mode, truncate the file if it exists
              $fileHandle = fopen($filePath, 'wb');

              $chunksize = 16;
              $bitDepth = 8; //8bit
              $sampleRate = 44100; //CD quality
              $blockAlign = ($channels * ($bitDepth / 8));
              $averageBytesPerSecond = $sampleRate * $blockAlign;

              $input = $freqs;
              /*
               * Header chunk
               * dwFileLength will be calculated at the end, based upon the length of the audio data
               */
              $header = [
                'sGroupID' => 'RIFF',
                'dwFileLength' => 0,
                'sRiffType' => 'WAVE'
              ];

              /*
               * Format chunk
               */
              $fmtChunk = [
                'sGroupID' => 'fmt',
                'dwChunkSize' => $chunksize,
                'wFormatTag' => 1,
                'wChannels' => $channels,
                'dwSamplesPerSec' => $sampleRate,
                'dwAvgBytesPerSec' => $averageBytesPerSecond,
                'wBlockAlign' => $blockAlign,
                'dwBitsPerSample' => $bitDepth
              ];

              /*
               * Map all fields to pack flags
               * WAV format uses little-endian byte order
               */
              $fieldFormatMap = [
                'sGroupID' => 'A4',
                'dwFileLength' => 'V',
                'sRiffType' => 'A4',
                'dwChunkSize' => 'V',
                'wFormatTag' => 'v',
                'wChannels' => 'v',
                'dwSamplesPerSec' => 'V',
                'dwAvgBytesPerSec' => 'V',
                'wBlockAlign' => 'v',
                'dwBitsPerSample' => 'v' //Some resources say this is a uint but it's not - stay woke.
              ];
              /*
               * Pack and write our values
               * Keep track of how many bytes we write so we can update the dwFileLength in the header
               */
              $dwFileLength = 0;
              foreach ($header as $currKey => $currValue) {
                if (!array_key_exists($currKey, $fieldFormatMap)) {
                  $message = 'Unrecognized header key value ' . $currKey;
                  \Drupal::logger('jellomatrix')->error($message);
                  die('Unrecognized field ' . $currKey);
                }

                $currPackFlag = $fieldFormatMap[$currKey];
                $currOutput = pack($currPackFlag, $currValue);
                $dwFileLength += fwrite($fileHandle, $currOutput);
              }

              foreach ($fmtChunk as $currKey => $currValue) {
                if (!array_key_exists($currKey, $fieldFormatMap)) {
                  $message = 'Unrecognized fmtChunk key value ' . $currKey;
                  \Drupal::logger('jellomatrix')->error($message);
                  die('Unrecognized field ' . $currKey);
                }

                $currPackFlag = $fieldFormatMap[$currKey];
                $currOutput = pack($currPackFlag, $currValue);
                $dwFileLength += fwrite($fileHandle, $currOutput);
              }
              /*
               * Set up our data chunk
               * As we write data, the dwChunkSize in this struct will be updated, be sure to pack and overwrite
               * after audio data has been written
               */
              $dataChunk = [
                'sGroupID' => 'data',
                'dwChunkSize' => 0
              ];

              //Write sGroupID
              $dwFileLength += fwrite($fileHandle, pack($fieldFormatMap['sGroupID'], $dataChunk['sGroupID']));

              //Save a reference to the position in the file of the dwChunkSize field so we can overwrite later
              $dataChunkSizePosition = $dwFileLength;

              //Write our empty dwChunkSize field
              $dwFileLength += fwrite($fileHandle, pack($fieldFormatMap['dwChunkSize'], $dataChunk['dwChunkSize']));

              /*
               8-bit audio: -128 to 127 (because of 2’s complement)
               */
              $maxAmplitude = 127;


              //Loop through input
              foreach ($input as $currNote) {
                //dpm($currNote);
                $currHz = (int)$currNote[0];

                $currMillis = 1000;

                /*
                 * Each "tick" should be 1 second divided by our sample rate. Since we're counting in milliseconds, use
                 * 1000/$sampleRate
                 */
                $timeIncrement = 1000 / $sampleRate;

                /*
                 * Define how much each tick should advance the sine function. 360deg/(sample rate/frequency)
                 */
                if ($currHz == 0) {
                  $currHz = .00001;
                }
                if ($currHz >= 10000) {
                  $currHz = .00001;
                }

                $waveIncrement = $sampleRate / ($sampleRate / $currHz);

                /*
                 * Run the sine function until we have written all the samples to fill the current note time
                 */
                $elapsed = 0;

                $x = 0;

                while ($elapsed < $currMillis) {
                  /*
                   * The sine wave math
                   * $maxAmplitude*.95 lowers the output a bit so we're not right up at 0db
                   */

                  $currAmplitude = ($maxAmplitude) - number_format(sin(deg2rad($x)) * ($maxAmplitude * .95));

                  //Increment our position in the wave
                  $x += $waveIncrement;

                  //Write the sample and increment our byte counts
                  $currBytesWritten = fwrite($fileHandle, pack('c', $currAmplitude));

                  $dataChunk['dwChunkSize'] += $currBytesWritten;
                  $dwFileLength += $currBytesWritten;


                  //Update the time counter
                  $elapsed += $timeIncrement;
                }
              }


              /*
               * Seek to our dwFileLength and overwrite it with our final value. Make sure to subtract 8 for the
               * sGroupID and sRiffType fields in the header.
               */
              fseek($fileHandle, 4);
              fwrite($fileHandle, pack($fieldFormatMap['dwFileLength'], ($dwFileLength - 8)));

              //Seek to our dwChunkSize and overwrite it with our final value
              fseek($fileHandle, $dataChunkSizePosition);
              fwrite($fileHandle, pack($fieldFormatMap['dwChunkSize'], $dataChunk['dwChunkSize']));
              fclose($fileHandle);

            }
          }
          // BOOKMARK set this to one to test again
          /*if ($channels > 1) {

            //Path to output file
            $filePath = 'sites/default/files/' . $ke . $tone . '_' . $interval . $direction . $frequency . '.wav';

            //Open a handle to our file in write mode, truncate the file if it exists
            $fileHandle = fopen($filePath, 'wb');

            /* JOINWAV
             $channels = 1; //Mono

            $chunksize = 16;
            $bitDepth = 8; //8bit
            $sampleRate = 44100; //CD quality
            $blockAlign = ($channels * ($bitDepth / 8));
            $averageBytesPerSecond = $sampleRate * $blockAlign;


            $input = $collection;

            if ($channels == 2) {
              /*
               * Header chunk
               * dwFileLength will be calculated at the end, based upon the length of the audio data
               *
              $header = [
                'sGroupID' => 'RIFF',
                'dwFileLength' => 0,
                'sRiffType' => 'WAVE'
              ];

              /*
               * Format chunk
               *
              $subChunkSize = 4;
              $subChunkIDSize = 4;
              $subChunk = 4;
              $chunksize = 4;
              $format = 4;
              $fmtChunk = [
                'subChunkID1' => 'fmt',
                'subChunk1' => $subChunk,
                'subChunk1Size' => $subChunkSize,
                'subChunk2' => $subChunk,
                'subChunkID2' => 'fmt',
                'subChunk2Size' => $subChunkSize,
                'wFormatTag' => 1,
                'wChannels' => $channels,
                'dwSamplesPerSec' => $sampleRate,
                'dwAvgBytesPerSec' => $averageBytesPerSecond,
                'wBlockAlign' => $blockAlign,
                'dwBitsPerSample' => $bitDepth,
                'sGroupID' => 'fmt',
                'dwChunkSize' => $chunksize + $format + ($subChunkSize * $channels) + ($subChunkIDSize * $channels) + ($subChunk * $channels)
              ];

              /*
               * Map all fields to pack flags
               * WAV format uses little-endian byte order
               *
              $fieldFormatMap = [
                'sGroupID' => 'A4',
                'dwFileLength' => 'V',
                'sRiffType' => 'A4',
                'dwChunkSize' => 'V',
                'wFormatTag' => 'v',
                'wChannels' => 'v',
                'dwSamplesPerSec' => 'V',
                'dwAvgBytesPerSec' => 'V',
                'wBlockAlign' => 'v',
                'dwBitsPerSample' => 'v', //Some resources say this is a uint but it's not - stay woke.
                'subChunk1Size' => 'V',
                'subChunk2Size' => 'V',
                'subChunk1' => 'V',
                'subChunk2' => 'V',
                'subChunkID1' => 'A4',
                'subChunkID2' => 'A4'
              ];
            }
            if ($channels == 6) {
              /*
               * Header chunk
               * dwFileLength will be calculated at the end, based upon the length of the audio data
               *
              $header = [
                'sGroupID' => 'RIFF',
                'dwFileLength' => 0,
                'sRiffType' => 'WAVE'
              ];

              /*
               * Format chunk
               *
              $subChunkSize = 4;
              $subChunkIDSize = 4;
              $subChunk = 4;
              $chunksize = 4;
              $format = 4;
              $fmtChunk = [
                'subChunkID1' => 'fmt',
                'subChunk1' => $subChunk,
                'subChunk1Size' => $subChunkSize,
                'subChunk2' => $subChunk,
                'subChunkID2' => 'fmt',
                'subChunk2Size' => $subChunkSize,
                'subChunkID3' => 'fmt',
                'subChunk3' => $subChunk,
                'subChunk3Size' => $subChunkSize,
                'subChunk4' => $subChunk,
                'subChunkID4' => 'fmt',
                'subChunk4Size' => $subChunkSize,
                'subChunkID5' => 'fmt',
                'subChunk5' => $subChunk,
                'subChunk5Size' => $subChunkSize,
                'subChunk6' => $subChunk,
                'subChunkID6' => 'fmt',
                'subChunk6Size' => $subChunkSize,
                'wFormatTag' => 1,
                'wChannels' => $channels,
                'dwSamplesPerSec' => $sampleRate,
                'dwAvgBytesPerSec' => $averageBytesPerSecond,
                'wBlockAlign' => $blockAlign,
                'dwBitsPerSample' => $bitDepth,
                'sGroupID' => 'fmt',
                'dwChunkSize' => $chunksize + $format + ($subChunkSize * $channels) + ($subChunkIDSize * $channels) + ($subChunk * $channels)
              ];

              /*
               * Map all fields to pack flags
               * WAV format uses little-endian byte order
               *
              $fieldFormatMap = [
                'sGroupID' => 'A4',
                'dwFileLength' => 'V',
                'sRiffType' => 'A4',
                'dwChunkSize' => 'V',
                'wFormatTag' => 'v',
                'wChannels' => 'v',
                'dwSamplesPerSec' => 'V',
                'dwAvgBytesPerSec' => 'V',
                'wBlockAlign' => 'v',
                'dwBitsPerSample' => 'v', //Some resources say this is a uint but it's not - stay woke.
                'subChunk1Size' => 'V',
                'subChunk2Size' => 'V',
                'subChunk1' => 'V',
                'subChunk2' => 'V',
                'subChunkID1' => 'A4',
                'subChunkID2' => 'A4',
                'subChunk3Size' => 'V',
                'subChunk4Size' => 'V',
                'subChunk3' => 'V',
                'subChunk4' => 'V',
                'subChunkID3' => 'A4',
                'subChunkID4' => 'A4',
                'subChunk5Size' => 'V',
                'subChunk6Size' => 'V',
                'subChunk5' => 'V',
                'subChunk6' => 'V',
                'subChunkID5' => 'A4',
                'subChunkID6' => 'A4'
              ];
            }

            /*
             * Pack and write our values
             * Keep track of how many bytes we write so we can update the dwFileLength in the header
             *
            $dwFileLength = 0;
            foreach ($header as $currKey => $currValue) {
              if (!array_key_exists($currKey, $fieldFormatMap)) {
                $message = 'Unrecognized header key value ' . $currKey;
                \Drupal::logger('jellomatrix')->error($message);
                die('Unrecognized field ' . $currKey);
              }

              $currPackFlag = $fieldFormatMap[$currKey];
              $currOutput = pack($currPackFlag, $currValue);
              $dwFileLength += fwrite($fileHandle, $currOutput);
            }

            foreach ($fmtChunk as $currKey => $currValue) {
              if (!array_key_exists($currKey, $fieldFormatMap)) {
                $message = 'Unrecognized fmtChunk key value ' . $currKey;
                \Drupal::logger('jellomatrix')->error($message);
                die('Unrecognized field ' . $currKey);
              }

              $currPackFlag = $fieldFormatMap[$currKey];
              $currOutput = pack($currPackFlag, $currValue);
              $dwFileLength += fwrite($fileHandle, $currOutput);
            }
            /*
             * Set up our data chunk
             * As we write data, the dwChunkSize in this struct will be updated, be sure to pack and overwrite
             * after audio data has been written
             *
            $dataChunk = [
              'sGroupID' => 'data',
              'dwChunkSize' => 0
            ];

            //Write sGroupID
            $dwFileLength += fwrite($fileHandle, pack($fieldFormatMap['sGroupID'], $dataChunk['sGroupID']));

            //Save a reference to the position in the file of the dwChunkSize field so we can overwrite later
            $dataChunkSizePosition = $dwFileLength;

            //Write our empty dwChunkSize field
            $dwFileLength += fwrite($fileHandle, pack($fieldFormatMap['dwChunkSize'], $dataChunk['dwChunkSize']));

            /*
             8-bit audio: -128 to 127 (because of 2’s complement)
             *
            $maxAmplitude = 127;

            //Loop through input
            foreach ($input as $array) {
              foreach ($array as $currSet) {
                foreach ($currSet as $currNote) {

                  //dpm($currNote);
                  $currHz = (int)$currNote[0];

                  if ($channels == 2) {
                    $currHz2 = (int)$currNote[1];
                  } elseif ($channels == 6) {
                    $currHz2 = (int)$currNote[1];
                    $currHz3 = (int)$currNote[2];
                    $currHz4 = (int)$currNote[3];
                    $currHz5 = (int)$currNote[4];
                    $currHz6 = (int)$currNote[5];
                  }


                  $currMillis = 2000;

                  /*
                   * Each "tick" should be 1 second divided by our sample rate. Since we're counting in milliseconds, use
                   * 1000/$sampleRate
                   *
                  $timeIncrement = 1000 / $sampleRate;

                  /*
                   * Define how much each tick should advance the sine function. 360deg/(sample rate/frequency)
                   *
                  if ($currHz == 0) {
                    $currHz = .00001;
                  }

                  if (isset($currHz2) && $currHz2 == 0) {
                    $currHz2 = .00001;
                  }
                  if (isset($currHz3) && $currHz3 == 0) {
                    $currHz3 = .00001;
                  }
                  if (isset($currHz4) && $currHz4 == 0) {
                    $currHz4 = .00001;
                  }
                  if (isset($currHz5) && $currHz5 == 0) {
                    $currHz5 = .00001;
                  }
                  if (isset($currHz6) && $currHz6 == 0) {
                    $currHz6 = .00001;
                  }

                  $waveIncrement = $sampleRate / ($sampleRate / $currHz);

                  if ($channels == 2) {
                    $waveIncrement2 = $sampleRate / ($sampleRate / $currHz2);
                  }
                  if ($channels == 6) {
                    $waveIncrement2 = $sampleRate / ($sampleRate / $currHz2);
                    $waveIncrement3 = $sampleRate / ($sampleRate / $currHz3);
                    $waveIncrement4 = $sampleRate / ($sampleRate / $currHz4);
                    $waveIncrement5 = $sampleRate / ($sampleRate / $currHz5);
                    $waveIncrement6 = $sampleRate / ($sampleRate / $currHz6);
                  }

                  /*
                   * Run the sine function until we have written all the samples to fill the current note time
                   *
                  $elapsed = 0;

                  $x = 0;
                  $x2 = 0;
                  $x3 = 0;
                  $x4 = 0;
                  $x5 = 0;
                  $x6 = 0;

                  if ($channels == 2) {
                    while ($elapsed < $currMillis) {
                      /*
                       * The sine wave math
                       * $maxAmplitude*.95 lowers the output a bit so we're not right up at 0db
                       *

                      $currAmplitude = ($maxAmplitude) - number_format(sin(deg2rad($x)) * ($maxAmplitude * .95));
                      $currAmplitude2 = ($maxAmplitude) - number_format(sin(deg2rad($x2)) * ($maxAmplitude * .95));

                      //Increment our position in the wave
                      $x += $waveIncrement;
                      $x2 += $waveIncrement2;

                      //Write the sample and increment our byte counts
                      // BOOKMARK ERROR HERE
                      $currBytesWritten = fwrite($fileHandle, pack('c', $currAmplitude));
                      $currBytesWritten = fwrite($fileHandle, pack('c', $currAmplitude2));

                      $dataChunk['dwChunkSize'] += $currBytesWritten;

                      $dwFileLength += $currBytesWritten;


                      //Update the time counter
                      $elapsed += $timeIncrement;
                    }
                  }
                  if ($channels == 6) {
                    while ($elapsed < $currMillis) {
                      /*
                       * The sine wave math
                       * $maxAmplitude*.95 lowers the output a bit so we're not right up at 0db
                       *

                      $currAmplitude = ($maxAmplitude) - number_format(sin(deg2rad($x)) * ($maxAmplitude * .95));
                      $currAmplitude2 = ($maxAmplitude) - number_format(sin(deg2rad($x2)) * ($maxAmplitude * .95));
                      $currAmplitude3 = ($maxAmplitude) - number_format(sin(deg2rad($x3)) * ($maxAmplitude * .95));
                      $currAmplitude4 = ($maxAmplitude) - number_format(sin(deg2rad($x4)) * ($maxAmplitude * .95));
                      $currAmplitude5 = ($maxAmplitude) - number_format(sin(deg2rad($x5)) * ($maxAmplitude * .95));
                      $currAmplitude6 = ($maxAmplitude) - number_format(sin(deg2rad($x6)) * ($maxAmplitude * .95));

                      //Increment our position in the wave
                      $x += $waveIncrement;
                      $x2 += $waveIncrement2;
                      $x3 += $waveIncrement3;
                      $x4 += $waveIncrement4;
                      $x5 += $waveIncrement5;
                      $x6 += $waveIncrement6;

                      //Write the sample and increment our byte counts
                      // BOOKMARK ERROR HERE
                      $currBytesWritten = fwrite($fileHandle, pack('c', $currAmplitude));
                      $currBytesWritten = fwrite($fileHandle, pack('c', $currAmplitude2));
                      $currBytesWritten = fwrite($fileHandle, pack('c', $currAmplitude3));
                      $currBytesWritten = fwrite($fileHandle, pack('c', $currAmplitude4));
                      $currBytesWritten = fwrite($fileHandle, pack('c', $currAmplitude5));
                      $currBytesWritten = fwrite($fileHandle, pack('c', $currAmplitude6));

                      $dataChunk['dwChunkSize'] += $currBytesWritten;

                      $dwFileLength += $currBytesWritten;



                      //Update the time counter
                      $elapsed += $timeIncrement;
                    }
                  }
                }

                /*
                 * Seek to our dwFileLength and overwrite it with our final value. Make sure to subtract 8 for the
                 * sGroupID and sRiffType fields in the header.
                 *
                fseek($fileHandle, 4);
                fwrite($fileHandle, pack($fieldFormatMap['dwFileLength'], ($dwFileLength - 8)));

                //Seek to our dwChunkSize and overwrite it with our final value
                fseek($fileHandle, $dataChunkSizePosition);
                fwrite($fileHandle, pack($fieldFormatMap['dwChunkSize'], $dataChunk['dwChunkSize']));
                fclose($fileHandle);

              }
            }
          }*/
        }
      }
    }
  }

  if ($print == 4) {
    $fileHandles = [];
    $rife = [];
    $rife[] = $frequency;
    $old_frequency = $frequency;
    for ($w = 0; $w <= 2; $w++) {
      $new_frequency = (int) $old_frequency * 11;
      $rife[] = $new_frequency;
      $old_frequency = $new_frequency;
    }
    foreach ($rife as $eleventh_harmonic) {
      //Path to output file
      $filePath = 'sites/default/files/rife_' . $eleventh_harmonic . '_base' . $frequency . 'eleventh_harmonic.wav';

      //Open a handle to our file in write mode, truncate the file if it exists
      $fileHandle = fopen($filePath, 'wb');
      $channels = 1;
      $chunksize = 16;
      $bitDepth = 8; //8bit
      $sampleRate = 44100; //CD quality
      $blockAlign = ($channels * ($bitDepth / 8));
      $averageBytesPerSecond = $sampleRate * $blockAlign;

      $input = $eleventh_harmonic;
      /*
       * Header chunk
       * dwFileLength will be calculated at the end, based upon the length of the audio data
       */
      $header = [
        'sGroupID' => 'RIFF',
        'dwFileLength' => 0,
        'sRiffType' => 'WAVE'
      ];

      /*
       * Format chunk
       */
      $fmtChunk = [
        'sGroupID' => 'fmt',
        'dwChunkSize' => $chunksize,
        'wFormatTag' => 1,
        'wChannels' => $channels,
        'dwSamplesPerSec' => $sampleRate,
        'dwAvgBytesPerSec' => $averageBytesPerSecond,
        'wBlockAlign' => $blockAlign,
        'dwBitsPerSample' => $bitDepth
      ];

      /*
       * Map all fields to pack flags
       * WAV format uses little-endian byte order
       */
      $fieldFormatMap = [
        'sGroupID' => 'A4',
        'dwFileLength' => 'V',
        'sRiffType' => 'A4',
        'dwChunkSize' => 'V',
        'wFormatTag' => 'v',
        'wChannels' => 'v',
        'dwSamplesPerSec' => 'V',
        'dwAvgBytesPerSec' => 'V',
        'wBlockAlign' => 'v',
        'dwBitsPerSample' => 'v' //Some resources say this is a uint but it's not - stay woke.
      ];
      /*
       * Pack and write our values
       * Keep track of how many bytes we write so we can update the dwFileLength in the header
       */
      $dwFileLength = 0;
      foreach ($header as $currKey => $currValue) {
        if (!array_key_exists($currKey, $fieldFormatMap)) {
          $message = 'Unrecognized header key value ' . $currKey;
          \Drupal::logger('jellomatrix')->error($message);
          die('Unrecognized field ' . $currKey);
        }

        $currPackFlag = $fieldFormatMap[$currKey];
        $currOutput = pack($currPackFlag, $currValue);
        $dwFileLength += fwrite($fileHandle, $currOutput);
      }

      foreach ($fmtChunk as $currKey => $currValue) {
        if (!array_key_exists($currKey, $fieldFormatMap)) {
          $message = 'Unrecognized fmtChunk key value ' . $currKey;
          \Drupal::logger('jellomatrix')->error($message);
          die('Unrecognized field ' . $currKey);
        }

        $currPackFlag = $fieldFormatMap[$currKey];
        $currOutput = pack($currPackFlag, $currValue);
        $dwFileLength += fwrite($fileHandle, $currOutput);
      }
      /*
       * Set up our data chunk
       * As we write data, the dwChunkSize in this struct will be updated, be sure to pack and overwrite
       * after audio data has been written
       */
      $dataChunk = [
        'sGroupID' => 'data',
        'dwChunkSize' => 0
      ];

      //Write sGroupID
      $dwFileLength += fwrite($fileHandle, pack($fieldFormatMap['sGroupID'], $dataChunk['sGroupID']));

      //Save a reference to the position in the file of the dwChunkSize field so we can overwrite later
      $dataChunkSizePosition = $dwFileLength;

      //Write our empty dwChunkSize field
      $dwFileLength += fwrite($fileHandle, pack($fieldFormatMap['dwChunkSize'], $dataChunk['dwChunkSize']));

      /*
       8-bit audio: -128 to 127 (because of 2’s complement)
       */
      $maxAmplitude = 127;


      //Loop through input
      for ($z = 0; $z < 60; $z++) {
        //dpm($currNote);
        $currHz = (int)$input;

        $currMillis = 1000;

        /*
         * Each "tick" should be 1 second divided by our sample rate. Since we're counting in milliseconds, use
         * 1000/$sampleRate
         */
        $timeIncrement = 1000 / $sampleRate;

        /*
         * Define how much each tick should advance the sine function. 360deg/(sample rate/frequency)
         */
        if ($currHz == 0) {
          $currHz = .00001;
        }

        $waveIncrement = $sampleRate / ($sampleRate / $currHz);

        /*
         * Run the sine function until we have written all the samples to fill the current note time
         */
        $elapsed = 0;

        $x = 0;

        while ($elapsed < $currMillis) {
          /*
           * The sine wave math
           * $maxAmplitude*.95 lowers the output a bit so we're not right up at 0db
           */

          $currAmplitude = ($maxAmplitude) - number_format(sin(deg2rad($x)) * ($maxAmplitude * .95));

          //Increment our position in the wave
          $x += $waveIncrement;

          //Write the sample and increment our byte counts
          $currBytesWritten = fwrite($fileHandle, pack('c', $currAmplitude));

          $dataChunk['dwChunkSize'] += $currBytesWritten;
          $dwFileLength += $currBytesWritten;


          //Update the time counter
          $elapsed += $timeIncrement;
        }
      }


      /*
       * Seek to our dwFileLength and overwrite it with our final value. Make sure to subtract 8 for the
       * sGroupID and sRiffType fields in the header.
       */
      fseek($fileHandle, 4);
      fwrite($fileHandle, pack($fieldFormatMap['dwFileLength'], ($dwFileLength - 8)));

      //Seek to our dwChunkSize and overwrite it with our final value
      fseek($fileHandle, $dataChunkSizePosition);
      fwrite($fileHandle, pack($fieldFormatMap['dwChunkSize'], $dataChunk['dwChunkSize']));
      fclose($fileHandle);

      $fileHandles[] = $fileHandle;
    }
  }
  if ($print == 5) {
    $fileHandles = [];
    $rife = [];
    $rife[] = $frequency;
    $old_frequency = $frequency;
    for ($w = 0; $w <= 2; $w++) {
      $new_frequency = (int) $old_frequency * 11;
      $rife[] = $new_frequency;
      $old_frequency = $new_frequency;
    }
    foreach ($rife as $eleventh) {
      $fileHandles[] = 'sites/default/files/rife_' . $eleventh . '_base' . $frequency . 'eleventh_harmonic.wav';
    }

    $combined_wav_data = jellomatrix_joinwavs($fileHandles, $frequency);

    $path = 'sites/default/files/rife_complete_base_' . $frequency . '.wav';
    $handle = fopen($path, "wb");
    fwrite($handle, $combined_wav_data);
    fclose($handle);


  }

  /*
   * JOINWAVS
   */
   if ($print == 2) {

    if (file_exists('/home/anawil2/jellobrain.com/sites/default/files/forward' . $tone . '_' . $interval . 'r' . $frequency . '.wav')) {
      $r_set = [];
      $r_set[] = '/home/anawil2/jellobrain.com/sites/default/files/forward' . $tone . '_' . $interval . 'r' . $frequency . '.wav';
      $r_set[] = '/home/anawil2/jellobrain.com/sites/default/files/backward'. $tone . '_' . $interval . 'rd' . $frequency . '.wav';
      $r = jellomatrix_joinwavs($r_set, $frequency);

      $path = 'sites/default/files/pair' . $tone . '_' . $interval . '_rset_' . $frequency . '.wav';
      $pathHandle = fopen($path, 'wb');
      fwrite($pathHandle,$r);
      fclose($pathHandle);
    }

    if (file_exists('/home/anawil2/jellobrain.com/sites/default/files/forward' . $tone . '_' . $interval . 'rl' . $frequency . '.wav')) {
      $rl_set = [];
      $rl_set[] = '/home/anawil2/jellobrain.com/sites/default/files/forward' . $tone . '_' . $interval . 'rl' . $frequency . '.wav';
      $rl_set[] = '/home/anawil2/jellobrain.com/sites/default/files/backward' . $tone . '_' . $interval . 'rld' . $frequency . '.wav';
      $rl = jellomatrix_joinwavs($rl_set, $frequency);

      $path = 'sites/default/files/pair' . $tone . '_' . $interval . '_rlset_' . $frequency . '.wav';
      $pathHandle = fopen($path, 'wb');
      fwrite($pathHandle,$rl);
      fclose($pathHandle);
    }

    if (file_exists('/home/anawil2/jellobrain.com/sites/default/files/forward' . $tone . '_' . $interval . 'lr' . $frequency . '.wav')) {
      $lr_set = [];
      $lr_set[] = '/home/anawil2/jellobrain.com/sites/default/files/forward' . $tone . '_' . $interval . 'lr' . $frequency . '.wav';
      $lr_set[] = '/home/anawil2/jellobrain.com/sites/default/files/backward' . $tone . '_' . $interval . 'lrd' . $frequency . '.wav';
      $lr = jellomatrix_joinwavs($lr_set, $frequency);

      $path = 'sites/default/files/pair' . $tone . '_' . $interval . '_lrset_' . $frequency . '.wav';
      $pathHandle = fopen($path, 'wb');
      fwrite($pathHandle,$lr);
      fclose($pathHandle);
    }
  }
  if ($print == 3) {
    $c_set = [];

    if (file_exists('/home/anawil2/jellobrain.com/sites/default/files/forward' . $tone . '_' . $interval . 'lr' . $frequency . '.wav')) {
      $c_set[] = '/home/anawil2/jellobrain.com/sites/default/files/forward' . $tone . '_' . $interval . 'r' . $frequency . '.wav';
    }
    if (file_exists('/home/anawil2/jellobrain.com/sites/default/files/forward' . $tone . '_' . $interval . 'lr' . $frequency . '.wav')) {
      $c_set[] = '/home/anawil2/jellobrain.com/sites/default/files/backward'. $tone . '_' . $interval . 'rd' . $frequency . '.wav';
    }
    if (file_exists('/home/anawil2/jellobrain.com/sites/default/files/forward' . $tone . '_' . $interval . 'lr' . $frequency . '.wav')) {
      $c_set[] = '/home/anawil2/jellobrain.com/sites/default/files/forward' . $tone . '_' . $interval . 'rl' . $frequency . '.wav';
    }
    if (file_exists('/home/anawil2/jellobrain.com/sites/default/files/forward' . $tone . '_' . $interval . 'lr' . $frequency . '.wav')) {
      $c_set[] = '/home/anawil2/jellobrain.com/sites/default/files/backward' . $tone . '_' . $interval . 'rld' . $frequency . '.wav';
    }
    if (file_exists('/home/anawil2/jellobrain.com/sites/default/files/forward' . $tone . '_' . $interval . 'lr' . $frequency . '.wav')) {
      $c_set[] = '/home/anawil2/jellobrain.com/sites/default/files/forward' . $tone . '_' . $interval . 'lr' . $frequency . '.wav';
    }
    if (file_exists('/home/anawil2/jellobrain.com/sites/default/files/forward' . $tone . '_' . $interval . 'lr' . $frequency . '.wav')) {
      $c_set[] = '/home/anawil2/jellobrain.com/sites/default/files/backward' . $tone . '_' . $interval . 'lrd' . $frequency . '.wav';
    }

    $c = jellomatrix_joinwavs($c_set, $frequency);

    $path = 'sites/default/files/complete' . $tone . '_' . $interval . '_cset_' . $frequency . '.wav';
    $pathHandle = fopen($path, 'wb');
    fwrite($pathHandle,$c);
    fclose($pathHandle);
  }
}


// BOOKMARK: OUTPUT BLOCKS

function jellomatrix_joinwavs($wavs, $frequency) {

  $fields = join('/', array('H8ChunkID', 'VChunkSize', 'H8Format',
    'H8Subchunk1ID', 'VSubchunk1Size',
    'vAudioFormat', 'vNumChannels', 'VSampleRate',
    'VByteRate', 'vBlockAlign', 'vBitsPerSample'));
  $data = '';
  foreach ($wavs as $wav) {
    $fp = fopen($wav, 'rb');
    $header = fread($fp, 36);
    $info = unpack($fields, $header);

    if ($info['Subchunk1Size'] > 16) {
      $header .= fread($fp, ($info['Subchunk1Size'] - 16));
    }
    // read SubChunk2ID
    $header .= fread($fp, 4);
    // read Subchunk2Size
    $size = unpack('vsize', fread($fp, 4));
    $size = $size['size'];
    // read data
    $data .= fread($fp, $size);
  }
  return $header . pack('V', strlen($data)) . $data;
}

// BOOKMARK: OUTPUT BLOCKS

function jellomatrix_output_splicegrid_derivatives($increments, $primes, $tone, $interval, $harmonics, $frequency, $print) {
  $lambdoma_map = [];
  $note_assembly = [];
  $output = '';
  // Now output the differences between different integers.
  $output .= '<div class="endtable begintext"><h2>ODD+EVEN: Derivatives</h2>';
  $output .= '<p>The bold letters at the end of each row represent the Lambdona Notes that the ratios of repeating increments create.<br><div class="endtext"><br></div>';

  foreach($increments as $k=>$increment) {
    if ($k == 'row') {
      $r = '<h3>ODD+EVEN: Original Matrix</h3>';
      foreach ($increment as $ke => $direction) {
        if ($ke == 'forward') {
          $r .= '';
          $r .= '<p></p><div class="endtext"><br></div>';
          $count = 1;
          $r .= '<table class="table"><tr>';
          foreach ($direction as $spliced_row) {
            $r .= '<td class="tdgridltfirst">Row ' . $count . ': </td>';
            foreach ($spliced_row as $key => $item) {
              $test = $spliced_row;
              unset($clink); $clink = '';
              if (is_array($test)) {
                $a = array_pop($test);
                $b = array_pop($test);

                if (is_numeric($a) && ($a) % 2 == 0 && ($b) % 2 == 0) {
                  $clink = 'highlight';
                }
                elseif (is_numeric($a) && ($a) % 2 != 0 && ($b) % 2 != 0) {
                  $clink = 'highlight';
                }
              }
              if (isset($clink) && $clink == 'highlight') {
                $r .= '<td class="tdgrid highlight">' . $item . '</td>';
              }
              elseif (($item) % 2 == 0) {
                $r .= '<td class="tdgrid subhighlight">' . $item . '</td>';
              }
              elseif (($item) % 2 != 0) {
                $r .= '<td class="tdgrid">' . $item . '</td>';
              }
              if ($key == 0) {
                $zero = $item;
              }
              if ($key == 1) {
                $one = $item;
              }
              if ($key == 2) {
                $two = $item;
              }
              if ($key == 3) {
                $three = $item;
              }
              if ($key == 4) {
                $four = $item;
              }
              if ($key == 5) {
                $five = $item;
              }
              if ($key == 6) {
                $six = $item;
              }
              if ($key == 7) {
                $seven = $item;
              }
            }

            if (isset($three) && isset($one) && $three == $one) {
              $upper = $one;
            } else {
              unset($upper);
            }
            if (isset($four) && $two == $four) {
              $lower = $two;
            } else {
              unset($lower);
            }

            if (isset($upper)) {

              foreach ($harmonics as $note) {
                $explode = explode(':', $note);
                if (isset($lower) && $explode[0] == $upper && $explode[1] == $lower && !empty($explode[2])) {
                  $r .= '<td class="tdgrid"><strong>' . $explode[2] . '</strong></td>';
                  $note_order[]= $explode[3];
                  $lower = (int)$lower;
                  $upper = (int)$upper; $added = $upper+$lower;
                  if (is_numeric($upper) && is_numeric($lower)) {
                    $r .= '<td>' . $upper . '+' . $lower . '=<strong>' . $added . '</strong></td>';
                  }
                  $lambdoma_map[$k][$ke][$key][$count]['lower'] = $explode[0];
                  $lambdoma_map[$k][$ke][$key][$count]['upper'] = $explode[1];
                  $lambdoma_map[$k][$ke][$key][$count]['key'] = $explode[2];
                  if ($explode[2] == 'origin') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'black';
                  }
                  if ($explode[2] == 'C') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zcee';
                  }
                  elseif ($explode[2] == 'C#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zceesharp';
                  }
                  elseif ($explode[2] == 'D') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zdee';
                  }
                  elseif ($explode[2] == 'Eb') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zeeeflat';
                  }
                  elseif ($explode[2] == 'E') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zeee';
                  }
                  elseif ($explode[2] == 'F') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zeff';
                  }
                  elseif ($explode[2] == 'F#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zeffsharp';
                  }
                  elseif ($explode[2] == 'G') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zgee';
                  }
                  elseif ($explode[2] == 'G#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zgeesharp';
                  }
                  elseif ($explode[2] == 'A') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zay';
                  }
                  elseif ($explode[2] == 'Bb') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zbeeflat';
                  }
                  elseif ($explode[2] == 'B') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zbee';
                  }
                  else {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'darkslategray';
                  }
                  if (isset($explode[3])) {
                    $lambdoma_map[$k][$ke][$key][$count]['frequency'] = $explode[3];
                  }
                }
              }
            }
            $r .= '</tr>';
            $count++;
          }
          $r .= '</table>';
          $r .= '<h3>Order of frequencies: based on a ' . $frequency . 'Hz baseline or "C"</h3><ol>';
          if (isset($note_order)) {
            foreach ($note_order as $key => $hz) {

              $r .= '<li>' . $hz . 'Hz</li>';
            }
          }
          $r .= '</ol><hr>';
          $r .= '<div class="endtext"><br></div>';
          if (isset($note_order)) {
            $note_assembly[$ke]['r'][] = $note_order;
          }
        }

        if ($ke == 'derivative') {
          unset($note_order);
          $rd = '<h4>First Derivative (Odd/Even)</h4>';
          $count = 1;
          $rd .= '<table class="table"><tr>';
          foreach ($direction as $spliced_row) {
            $rd .= '<td class="tdgridltfirst">Row ' . $count . ': </td>';
            foreach ($spliced_row as $key => $item) {
              $test = $spliced_row;
              unset($clink); $clink = '';
              if (is_array($test)) {
                $a = array_pop($test);
                $b = array_pop($test);

                if (is_numeric($a) && ($a) % 2 == 0 && ($b) % 2 == 0) {
                  $clink = 'highlight';
                }
                elseif (is_numeric($a) && ($a) % 2 != 0 && ($b) % 2 != 0) {
                  $clink = 'highlight';
                }
              }
              if (isset($clink) && $clink == 'highlight') {
                $rd .= '<td class="tdgrid highlight">' . $item . '</td>';
              }
              elseif (($item) % 2 == 0) {
                $rd .= '<td class="tdgrid subhighlight">' . $item . '</td>';
              }
              elseif (($item) % 2 != 0) {
                $rd .= '<td class="tdgrid">' . $item . '</td>';
              }
              if ($key == 0) {
                $zero = $item;
              }
              if ($key == 1) {
                $one = $item;
              }
              if ($key == 2) {
                $two = $item;
              }
              if ($key == 3) {
                $three = $item;
              }
              if ($key == 4) {
                $four = $item;
              }
            }

            if (isset($three) && isset($one) && $three == $one) {
              $upper = $one;
            } else {
              unset($upper);
            }
            if (isset($four) && $two == $four) {
              $lower = $two;
            } else {
              unset($lower);
            }

            if (isset($upper)) {

              foreach ($harmonics as $note) {
                $explode = explode(':', $note);
                if (isset($lower) && $explode[0] == $upper && $explode[1] == $lower && !empty($explode[2])) {
                  $rd .= '<td class="tdgrid"><strong>' . $explode[2] . '</strong></td>';
                  $note_order[]= $explode[3];
                  $lower = (int)$lower;
                  $upper = (int)$upper; $added = $upper+$lower;
                  if (is_numeric($upper) && is_numeric($lower)) {
                    $rd .= '<td>' . $upper . '+' . $lower . '=<strong>' . $added . '</strong></td>';
                  }
                  $lambdoma_map[$k][$ke][$key][$count]['lower'] = $explode[0];
                  $lambdoma_map[$k][$ke][$key][$count]['upper'] = $explode[1];
                  $lambdoma_map[$k][$ke][$key][$count]['key'] = $explode[2];
                  if ($explode[2] == 'origin') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'black';
                  }
                  if ($explode[2] == 'C') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'cee';
                  }
                  elseif ($explode[2] == 'C#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'ceesharp';
                  }
                  elseif ($explode[2] == 'D') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'dee';
                  }
                  elseif ($explode[2] == 'Eb') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'eeeflat';
                  }
                  elseif ($explode[2] == 'E') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'eee';
                  }
                  elseif ($explode[2] == 'F') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'eff';
                  }
                  elseif ($explode[2] == 'F#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'effsharp';
                  }
                  elseif ($explode[2] == 'G') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'gee';
                  }
                  elseif ($explode[2] == 'G#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'geesharp';
                  }
                  elseif ($explode[2] == 'A') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'ay';
                  }
                  elseif ($explode[2] == 'Bb') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'beeflat';
                  }
                  elseif ($explode[2] == 'B') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'bee';
                  }
                  else {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'darkslategray';
                  }
                  if (isset($explode[3])) {
                    $lambdoma_map[$k][$ke][$key][$count]['frequency'] = $explode[3];
                  }
                }
              }
            }

            $rd .= '</tr>';
            $count++;
          }
          $rd .= '</table>';
          $rd .= '<h3>Order of frequencies: based on a ' . $frequency . 'Hz baseline or "C"</h3><ol>';
          if (isset($note_order)) {
            foreach ($note_order as $key => $hz) {

              $rd .= '<li>' . $hz . 'Hz</li>';
            }
          }
          $rd .= '</ol><hr>';
          $rd .= '<div class="endtext"><br></div>';
          if (isset($note_order)) {
            $note_assembly[$ke]['rd'][] = $note_order;
          }
        }


        if ($ke == 'derivative_2') {
          unset($note_order);
          $rd2 = '<h4>Second Derivative (Odd/Even)</h4>';
          $count = 1;
          $rd2 .= '<table class="table"><tr>';
          foreach ($direction as $spliced_row) {
            $rd2 .= '<td class="tdgridltfirst">Row ' . $count . ': </td>';
            foreach ($spliced_row as $key => $item) {
              $test = $spliced_row;
              unset($clink); $clink = '';
              if (is_array($test)) {
                $a = array_pop($test);
                $b = array_pop($test);

                if (is_numeric($a) && ($a) % 2 == 0 && ($b) % 2 == 0) {
                  $clink = 'highlight';
                }
                elseif (is_numeric($a) && ($a) % 2 != 0 && ($b) % 2 != 0) {
                  $clink = 'highlight';
                }
              }
              if (isset($clink) && $clink == 'highlight') {
                $rd2 .= '<td class="tdgrid highlight">' . $item . '</td>';
              }
              elseif (($item) % 2 == 0) {
                $rd2 .= '<td class="tdgrid subhighlight">' . $item . '</td>';
              }
              elseif (($item) % 2 != 0) {
                $rd2 .= '<td class="tdgrid">' . $item . '</td>';
              }
              if ($key == 0) {
                $zero = $item;
              }
              if ($key == 1) {
                $one = $item;
              }
              if ($key == 2) {
                $two = $item;
              }
              if ($key == 3) {
                $three = $item;
              }
              if ($key == 4) {
                $four = $item;
              }
            }

            if (isset($three) && isset($one) && $three == $one) {
              $upper = $one;
            } else {
              unset($upper);
            }
            if (isset($four) && $two == $four) {
              $lower = $two;
            } else {
              unset($lower);
            }
            if (isset($upper)) {

              foreach ($harmonics as $note) {
                $explode = explode(':', $note);
                if (isset($lower) && $explode[0] == $upper && $explode[1] == $lower && !empty($explode[2])) {
                  $rd2 .= '<td class="tdgrid"><strong>' . $explode[2] . '</strong></td>';
                  $note_order[]= $explode[3];
                  $lower = (int)$lower;
                  $upper = (int)$upper; $added = $upper+$lower;
                  if (is_numeric($upper) && is_numeric($lower)) {
                    $rd2 .= '<td>' . $upper . '+' . $lower . '=<strong>' . $added . '</strong></td>';
                  }
                  $lambdoma_map[$k][$ke][$key][$count]['lower'] = $explode[0];
                  $lambdoma_map[$k][$ke][$key][$count]['upper'] = $explode[1];
                  $lambdoma_map[$k][$ke][$key][$count]['key'] = $explode[2];
                  if ($explode[2] == 'origin') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'black';
                  }
                  if ($explode[2] == 'C') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'cee';
                  }
                  elseif ($explode[2] == 'C#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'ceesharp';
                  }
                  elseif ($explode[2] == 'D') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'dee';
                  }
                  elseif ($explode[2] == 'Eb') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'eeeflat';
                  }
                  elseif ($explode[2] == 'E') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'eee';
                  }
                  elseif ($explode[2] == 'F') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'eff';
                  }
                  elseif ($explode[2] == 'F#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'effsharp';
                  }
                  elseif ($explode[2] == 'G') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'gee';
                  }
                  elseif ($explode[2] == 'G#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'geesharp';
                  }
                  elseif ($explode[2] == 'A') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'ay';
                  }
                  elseif ($explode[2] == 'Bb') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'beeflat';
                  }
                  elseif ($explode[2] == 'B') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'bee';
                  }
                  else {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'darkslategray';
                  }
                  if (isset($explode[3])) {
                    $lambdoma_map[$k][$ke][$key][$count]['frequency'] = $explode[3];
                  }
                }
              }
            }
            $rd2 .= '</tr>';
            $count++;
          }
          $rd2 .= '</table>';
          $rd2 .= '<h3>Order of frequencies: based on a ' . $frequency . 'Hz baseline or "C"</h3><ol>';
          if (isset($note_order)) {
            foreach ($note_order as $key => $hz) {

              $rd2 .= '<li>' . $hz . 'Hz</li>';
            }
          }
          $rd2 .= '</ol><hr>';
          $rd2 .= '<div class="endtext"><br></div>';
          if (isset($note_order)) {
            $note_assembly[$ke]['rd2'][] = $note_order;
          }
        }
      }
    }
  }
///BOOKMARK
  $output .= $r;


  /*$output .= '<table><tr><th>k</th><th>ke</th><th>key</th><th>row</th><th>note</th><th>lower</th><th>upper</th></tr>';
  foreach($lambdoma_map as $k => $data) {
    foreach($data as $ke => $stuff) {
      foreach ($stuff as $key => $counts) {
        foreach ($counts as $count => $values) {
          $output .= "<tr><td>" . $k . "</td><td>" . $ke . "</td><td>" . $key . "</td><td>" . $count . "</td><td>" . $values['key'] . "</td><td>" . $values['lower'] . "</td><td>" . $values['upper'] . "</td></tr>";
        }
      }
    }
  }
  $output .= "</table>";*/

  $map = [];
  foreach ($lambdoma_map as $k => $data) {
    foreach ($data as $ke => $stuff) {
      //if ($ke = 'forward' || $k = 'row') {*/
      foreach ($stuff as $key => $counts) {
        foreach ($counts as $count => $values) {
          for ($u = 0; $u <= 16; $u++) {
            for ($l = 0; $l <= 16; $l++) {
              if (!in_array($values['upper'] . ':' . $values['lower'] . ':' . $values['class'] . ':' . $values['frequency'] . ':' . $values['key'], $map)) {
                $map[] = $values['upper'] . ':' . $values['lower'] . ':' . $values['class'] . ':' . $values['frequency'] . ':' . $values['key'];
              }
            }
          }
        }
      }
      //}
    }
  }

  $output .= '<h3>Lambdoma Keyboard (<a href="http://lambdoma.com" target="_blank">Barbara Hero</a>) colored in with the locally determined frequency , and the letter note values based on a 256Hz C.</h3><table><tr><th></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th><th>16</th></tr>';
  for ($u=0; $u<=16; $u++) {
    $output .= '<tr>';
    $output .= '<td>' . $u . '</td>';


    for ($l = 0; $l <= 16; $l++) {
      $class = 'white';
      foreach ($map as $n => $unexploded) {
        $exploded = explode(':', $unexploded);
        if ($exploded[0] == $l && $exploded[1] == $u && !empty($explode[2])) {
          $np = 'b' . $n;
          if ($n >= $tone ) {
            $np = $n - $tone;
            $np = 'f' . $np;
          }
          $class = $exploded[2];
          $freq = $exploded[3];
          $kay = $exploded[4] . ':' . $np;
          //$output .= '<td>' . $u . '</td>';
        }
        if ($class == 'white') {
          if ($l == 0) {
            $class = 'lightgray';
          }
          elseif ($u == 0) {
            $class = 'lightgray';
          }
        }
      }
      $output .= '<td class ="' . $class . '">' . $u . '/' . $l . '<br>';
      if (isset($freq) && $freq != 'INF' && $class != 'white' && $class != 'lightgray') {
        $output .= intval($freq) . 'Hz<br>' . $kay . '</td>';
      }
      elseif (isset($freq) && $freq == 'INF') {
        $output .= 'INF</td>';
      }
      else {
        $output .= '-<br>-</td>';
      }
    }
    $output .= '</tr>';
  }
  $output .= '</table>';

  $output .= $rd;


  $output .= '<h3>Lambdoma Keyboard (<a href="http://lambdoma.com" target="_blank">Barbara Hero</a>) colored in with the locally determined frequency , and the letter note values based on a 256Hz C.</h3><table><tr><th></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th><th>16</th></tr>';
  for ($u=0; $u<=16; $u++) {
    $output .= '<tr>';
    $output .= '<td>' . $u . '</td>';


    for ($l = 0; $l <= 16; $l++) {
      $class = 'white';
      foreach ($map as $n => $unexploded) {
        $exploded = explode(':', $unexploded);
        if ($exploded[0] == $l && $exploded[1] == $u && !empty($explode[2])) {
          $np = 'b' . $n;
          if ($n >= $tone ) {
            $np = $n - $tone;
            $np = 'f' . $np;
          }
          $class = $exploded[2];
          $freq = $exploded[3];
          $kay = $exploded[4] . ':' . $np;
          //$output .= '<td>' . $u . '</td>';
        }
        if ($class == 'white') {
          if ($l == 0) {
            $class = 'lightgray';
          }
          elseif ($u == 0) {
            $class = 'lightgray';
          }
        }
      }
      $output .= '<td class ="' . $class . '">' . $u . '/' . $l . '<br>';
      if (isset($freq) && $freq != 'INF' && $class != 'white' && $class != 'lightgray') {
        $output .= intval($freq) . 'Hz<br>' . $kay . '</td>';
      }
      elseif (isset($freq) && $freq == 'INF') {
        $output .= 'INF</td>';
      }
      else {
        $output .= '-<br>-</td>';
      }
    }
    $output .= '</tr>';
  }
  $output .= '</table>';

  $output .= $rd2;


  $output .= '<h3>Lambdoma Keyboard (<a href="http://lambdoma.com" target="_blank">Barbara Hero</a>) colored in with the locally determined frequency , and the letter note values based on a 256Hz C.</h3><table><tr><th></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th><th>16</th></tr>';
  for ($u=0; $u<=16; $u++) {
    $output .= '<tr>';
    $output .= '<td>' . $u . '</td>';



    for ($l = 0; $l <= 16; $l++) {
      $class = 'white';
      foreach ($map as $n => $unexploded) {
        $exploded = explode(':', $unexploded);
        if ($exploded[0] == $l && $exploded[1] == $u && !empty($explode[2])) {
          $np = 'b' . $n;
          if ($n >= $tone ) {
            $np = $n - $tone;
            $np = 'f' . $np;
          }
          $class = $exploded[2];
          $freq = $exploded[3];
          $kay = $exploded[4] . ':' . $np;
          //$output .= '<td>' . $u . '</td>';
        }
        if ($class == 'white') {
          if ($l == 0) {
            $class = 'lightgray';
          }
          elseif ($u == 0) {
            $class = 'lightgray';
          }
        }
      }
      $output .= '<td class ="' . $class . '">' . $u . '/' . $l . '<br>';
      if (isset($freq) && $freq != 'INF' && $class != 'white' && $class != 'lightgray') {
        $output .= intval($freq) . 'Hz<br>' . $kay . '</td>';
      }
      elseif (isset($freq) && $freq == 'INF') {
        $output .= 'INF</td>';
      }
      else {
        $output .= '-<br>-</td>';
      }
    }
    $output .= '</tr>';
  }
  $output .= '</table>';

  $output .= '</div><hr class="hr"><br></div>';

  // Now output the differences between different integers.
  $output .= '<div class="endtable begintext"><h2>PRIMES: Derivatives</h2>';
  $output .= '<p>The bold letters at the end of each row represent the Lambdona Notes that the ratios of repeating increments create.</p><div class="endtext"><br></div>';

  foreach($increments as $k=>$increment) {
    if ($k == 'row') {
      $r = '<h3>PRIMES: Original Matrix</h3>';
      foreach ($increment as $ke=>$direction) {
        if ($ke == 'forward') {
          unset($note_order);
          $r .= '';
          $r .= '<p></p><div class="endtext"><br></div>';
          $count = 1;
          $r .= '<table class="table"><tr>';
          foreach ($direction as $spliced_row) {
            $r .= '<td class="tdgridltfirst">Row ' . $count .': </td>';
            foreach ($spliced_row as $key=>$item) {
              if (in_array($item, $primes)) {
                $r .= '<td class="tdgrid subhighlight">' . $item . '</td>';
              }
              if (!in_array($item, $primes)) {
                $r .= '<td class="tdgrid">' . $item . '</td>';
              }
              if ($key == 0) {
                $zero = $item;
              }
              if ($key == 1) {
                $one = $item;
              }
              if ($key == 2) {
                $two = $item;
              }
              if ($key == 3) {
                $three = $item;
              }
              if ($key == 4) {
                $four = $item;
              }
            }

            if (isset($three) && isset($one) && $three == $one) {
              $upper = $one;
            } else {
              unset($upper);
            }
            if (isset($four) && $two == $four) {
              $lower = $two;
            } else {
              unset($lower);
            }

            ////dpm($upper);
            if (isset($upper)) {

              foreach ($harmonics as $note) {
                $explode = explode(':', $note);
                if (isset($lower) && $explode[0] == $upper && $explode[1] == $lower && !empty($explode[2])) {
                  $r .= '<td class="tdgrid"><strong>' . $explode[2] . '</strong></td>';
                  $note_order[]= $explode[3];
                  $lower = (int)$lower;
                  $upper = (int)$upper; $added = $upper+$lower;
                  if (is_numeric($upper) && is_numeric($lower)) {
                    $r .= '<td>' . $upper . '+' . $lower . '=<strong>' . $added . '</strong></td>';
                  }
                  $lambdoma_map[$k][$ke][$key][$count]['lower'] = $explode[0];
                  $lambdoma_map[$k][$ke][$key][$count]['upper'] = $explode[1];
                  $lambdoma_map[$k][$ke][$key][$count]['key'] = $explode[2];
                  if ($explode[2] == 'origin') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'black';
                  }
                  if ($explode[2] == 'C') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zcee';
                  }
                  elseif ($explode[2] == 'C#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zceesharp';
                  }
                  elseif ($explode[2] == 'D') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zdee';
                  }
                  elseif ($explode[2] == 'Eb') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zeeeflat';
                  }
                  elseif ($explode[2] == 'E') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zeee';
                  }
                  elseif ($explode[2] == 'F') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zeff';
                  }
                  elseif ($explode[2] == 'F#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zeffsharp';
                  }
                  elseif ($explode[2] == 'G') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zgee';
                  }
                  elseif ($explode[2] == 'G#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zgeesharp';
                  }
                  elseif ($explode[2] == 'A') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zay';
                  }
                  elseif ($explode[2] == 'Bb') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zbeeflat';
                  }
                  elseif ($explode[2] == 'B') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zbee';
                  }
                  else {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'darkslategray';
                  }
                  if (isset($explode[3])) {
                    $lambdoma_map[$k][$ke][$key][$count]['frequency'] = $explode[3];
                  }
                }
              }
            }
            $r .= '</tr>';
            $count++;
          }
          $r .= '</table>';
          $r .= '<h3>Order of frequencies: based on a ' . $frequency . 'Hz baseline or "C"</h3><ol>';
          if (isset($note_order)) {
            foreach ($note_order as $key => $hz) {

              $r .= '<li>' . $hz . 'Hz</li>';
            }
          }
          $r .= '</ol><hr>';
          $r .= '<div class="endtext"><br></div>';
          if (isset($note_order)) {
            $note_assembly[$ke]['r'][] = $note_order;
          }
        }
        if ($ke == 'derivative') {
          unset($note_order);
          $rd = '<h4>First Derivative (Primes)</h4>';
          $count = 1;
          $rd .= '<table class="table"><tr>';
          foreach ($direction as $spliced_row) {
            $rd .= '<td class="tdgridltfirst">Row ' . $count .': </td>';
            foreach ($spliced_row as $key=>$item) {
              if (in_array($item, $primes)) {
                $rd .= '<td class="tdgrid subhighlight">' . $item . '</td>';
              }
              if (!in_array($item, $primes)) {
                $rd .= '<td class="tdgrid">' . $item . '</td>';
              }
              if ($key == 0) {
                $zero = $item;
              }
              if ($key == 1) {
                $one = $item;
              }
              if ($key == 2) {
                $two = $item;
              }
              if ($key == 3) {
                $three = $item;
              }
              if ($key == 4) {
                $four = $item;
              }
            }

            if (isset($three) && isset($one) && $three == $one) {
              $upper = $one;
            } else {
              unset($upper);
            }
            if (isset($four) && $two == $four) {
              $lower = $two;
            } else {
              unset($lower);
            }

            if (isset($upper)) {

              foreach ($harmonics as $note) {
                $explode = explode(':', $note);
                if (isset($lower) && $explode[0] == $upper && $explode[1] == $lower && !empty($explode[2])) {
                  $rd .= '<td class="tdgrid"><strong>' . $explode[2] . '</strong></td>';
                  $note_order[]= $explode[3];
                  $lower = (int)$lower;
                  $upper = (int)$upper; $added = $upper+$lower;
                  if (is_numeric($upper) && is_numeric($lower)) {
                    $rd .= '<td>' . $upper . '+' . $lower . '=<strong>' . $added . '</strong></td>';
                  }
                  $lambdoma_map[$k][$ke][$key][$count]['lower'] = $explode[0];
                  $lambdoma_map[$k][$ke][$key][$count]['upper'] = $explode[1];
                  $lambdoma_map[$k][$ke][$key][$count]['key'] = $explode[2];
                  if ($explode[2] == 'origin') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'black';
                  }
                  if ($explode[2] == 'C') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'cee';
                  }
                  elseif ($explode[2] == 'C#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'ceesharp';
                  }
                  elseif ($explode[2] == 'D') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'dee';
                  }
                  elseif ($explode[2] == 'Eb') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'eeeflat';
                  }
                  elseif ($explode[2] == 'E') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'eee';
                  }
                  elseif ($explode[2] == 'F') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'eff';
                  }
                  elseif ($explode[2] == 'F#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'effsharp';
                  }
                  elseif ($explode[2] == 'G') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'gee';
                  }
                  elseif ($explode[2] == 'G#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'geesharp';
                  }
                  elseif ($explode[2] == 'A') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'ay';
                  }
                  elseif ($explode[2] == 'Bb') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'beeflat';
                  }
                  elseif ($explode[2] == 'B') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'bee';
                  }
                  else {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'darkslategray';
                  }
                  if (isset($explode[3])) {
                    $lambdoma_map[$k][$ke][$key][$count]['frequency'] = $explode[3];
                  }
                }
              }
            }
            $rd .= '</tr>';
            $count++;
          }
          $rd .= '</table>';
          $rd .= '<h3>Order of frequencies: based on a ' . $frequency . 'Hz baseline or "C"</h3><ol>';
          if (isset($note_order)) {
            foreach ($note_order as $key => $hz) {

              $rd .= '<li>' . $hz . 'Hz</li>';
            }
          }
          $rd .= '</ol><hr>';
          $rd .= '<div class="endtext"><br></div>';
          if (isset($note_order)) {
            $note_assembly[$ke]['rd'][] = $note_order;
          }
        }
        if ($ke == 'derivative_2') {
          unset($note_order);
          $rd2 = '<h4>Second Derivative (Primes)</h4>';
          $count = 1;
          $rd2 .= '<table class="table"><tr>';
          foreach ($direction as $spliced_row) {
            $rd2 .= '<td class="tdgridltfirst">Row ' . $count .': </td>';
            foreach ($spliced_row as $key=>$item) {
              if (in_array($item, $primes)) {
                $rd2 .= '<td class="tdgrid subhighlight">' . $item . '</td>';
              }
              if (!in_array($item, $primes)) {
                $rd2 .= '<td class="tdgrid">' . $item . '</td>';
              }
              if ($key == 0) {
                $zero = $item;
              }
              if ($key == 1) {
                $one = $item;
              }
              if ($key == 2) {
                $two = $item;
              }
              if ($key == 3) {
                $three = $item;
              }
              if ($key == 4) {
                $four = $item;
              }
            }

            if (isset($three) && isset($one) && $three == $one) {
              $upper = $one;
            } else {
              unset($upper);
            }
            if (isset($four) && $two == $four) {
              $lower = $two;
            } else {
              unset($lower);
            }

            if (isset($upper)) {

              foreach ($harmonics as $note) {
                $explode = explode(':', $note);
                if (isset($lower) && $explode[0] == $upper && $explode[1] == $lower && !empty($explode[2])) {
                  $rd2 .= '<td class="tdgrid"><strong>' . $explode[2] . '</strong></td>';
                  $note_order[]= $explode[3];
                  $lower = (int)$lower;
                  $upper = (int)$upper; $added = $upper+$lower;
                  if (is_numeric($upper) && is_numeric($lower)) {
                    $rd2 .= '<td>' . $upper . '+' . $lower . '=<strong>' . $added . '</strong></td>';
                  }
                  $lambdoma_map[$k][$ke][$key][$count]['lower'] = $explode[0];
                  $lambdoma_map[$k][$ke][$key][$count]['upper'] = $explode[1];
                  $lambdoma_map[$k][$ke][$key][$count]['key'] = $explode[2];
                  if ($explode[2] == 'origin') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'black';
                  }
                  if ($explode[2] == 'C') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'cee';
                  }
                  elseif ($explode[2] == 'C#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'ceesharp';
                  }
                  elseif ($explode[2] == 'D') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'dee';
                  }
                  elseif ($explode[2] == 'Eb') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'eeeflat';
                  }
                  elseif ($explode[2] == 'E') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'eee';
                  }
                  elseif ($explode[2] == 'F') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'eff';
                  }
                  elseif ($explode[2] == 'F#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'effsharp';
                  }
                  elseif ($explode[2] == 'G') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'gee';
                  }
                  elseif ($explode[2] == 'G#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'geesharp';
                  }
                  elseif ($explode[2] == 'A') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'ay';
                  }
                  elseif ($explode[2] == 'Bb') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'beeflat';
                  }
                  elseif ($explode[2] == 'B') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'bee';
                  }
                  else {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'darkslategray';
                  }
                  if (isset($explode[3])) {
                    $lambdoma_map[$k][$ke][$key][$count]['frequency'] = $explode[3];
                  }
                }
              }
            }
            $rd2 .= '</tr>';
            $count++;
          }
          $rd2 .= '</table>';
          $rd2 .= '<h3>Order of frequencies: based on a ' . $frequency . 'Hz baseline or "C"</h3><ol>';
          if (isset($note_order)) {
            foreach ($note_order as $key => $hz) {

              $rd2 .= '<li>' . $hz . 'Hz</li>';
            }
          }
          $rd2 .= '</ol><hr>';
          $rd2 .= '<div class="endtext"><br></div>';
          if (isset($note_order)) {
            $note_assembly[$ke]['rd2'][] = $note_order;
          }
        }
      }
    }
  }
  $output .= $r;

  /*$output .= '<table><tr><th>k</th><th>ke</th><th>key</th><th>row</th><th>note</th><th>lower</th><th>upper</th></tr>';
  foreach($lambdoma_map as $k => $data) {
    foreach($data as $ke => $stuff) {
      foreach ($stuff as $key => $counts) {
        foreach ($counts as $count => $values) {
          $output .= "<tr><td>" . $k . "</td><td>" . $ke . "</td><td>" . $key . "</td><td>" . $count . "</td><td>" . $values['key'] . "</td><td>" . $values['lower'] . "</td><td>" . $values['upper'] . "</td></tr>";
        }
      }
    }
  }
  $output .= "</table>";*/

  $map = [];
  foreach ($lambdoma_map as $k => $data) {
    foreach ($data as $ke => $stuff) {
      //if ($ke = 'forward' || $k = 'row') {*/
      foreach ($stuff as $key => $counts) {
        foreach ($counts as $count => $values) {
          for ($u = 0; $u <= 16; $u++) {
            for ($l = 0; $l <= 16; $l++) {
              if (!in_array($values['upper'] . ':' . $values['lower'] . ':' . $values['class'] . ':' . $values['frequency'] . ':' . $values['key'], $map)) {
                $map[] = $values['upper'] . ':' . $values['lower'] . ':' . $values['class'] . ':' . $values['frequency'] . ':' . $values['key'];
              }
            }
          }
        }
      }
      //}
    }
  }


  $output .= '<h3>Lambdoma Keyboard (<a href="http://lambdoma.com" target="_blank">Barbara Hero</a>) colored in with the locally determined frequency , and the letter note values based on a 256Hz C.</h3><table><tr><th></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th><th>16</th></tr>';
  for ($u=0; $u<=16; $u++) {

    $output .= '<tr>';
    $output .= '<td>' . $u . '</td>';


    for ($l = 0; $l <= 16; $l++) {
      $class = 'white';
      foreach ($map as $n => $unexploded) {
        $exploded = explode(':', $unexploded);
        if ($exploded[0] == $l && $exploded[1] == $u && !empty($explode[2])) {
          $np = 'b' . $n;
          if ($n >= $tone ) {
            $np = $n - $tone;
            $np = 'f' . $np;
          }
          $class = $exploded[2];
          $freq = $exploded[3];
          $kay = $exploded[4] . ':' . $np;
          //$output .= '<td>' . $u . '</td>';
        }
        if ($class == 'white') {
          if ($l == 0) {
            $class = 'lightgray';
          }
          elseif ($u == 0) {
            $class = 'lightgray';
          }
        }
      }
      $output .= '<td class ="' . $class . '">' . $u . '/' . $l . '<br>';
      if (isset($freq) && $freq != 'INF' && $class != 'white' && $class != 'lightgray') {
        $output .= intval($freq) . 'Hz<br>' . $kay . '</td>';
      }
      elseif (isset($freq) && $freq == 'INF') {
        $output .= 'INF</td>';
      }
      else {
        $output .= '-<br>-</td>';
      }
    }
    $output .= '</tr>';
  }
  $output .= '</table>';

  $output .= $rd;


  $output .= '<h3>Lambdoma Keyboard (<a href="http://lambdoma.com" target="_blank">Barbara Hero</a>) colored in with the locally determined frequency , and the letter note values based on a 256Hz C.</h3><table><tr><th></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th><th>16</th></tr>';
  for ($u=0; $u<=16; $u++) {
    $output .= '<tr>';
    $output .= '<td>' . $u . '</td>';


    for ($l = 0; $l <= 16; $l++) {
      $class = 'white';
      foreach ($map as $n => $unexploded) {
        $exploded = explode(':', $unexploded);
        if ($exploded[0] == $l && $exploded[1] == $u && !empty($explode[2])) {
          $np = 'b' . $n;
          if ($n >= $tone ) {
            $np = $n - $tone;
            $np = 'f' . $np;
          }
          $class = $exploded[2];
          $freq = $exploded[3];
          $kay = $exploded[4] . ':' . $np;
          //$output .= '<td>' . $u . '</td>';
        }
        if ($class == 'white') {
          if ($l == 0) {
            $class = 'lightgray';
          }
          elseif ($u == 0) {
            $class = 'lightgray';
          }
        }
      }
      $output .= '<td class ="' . $class . '">' . $u . '/' . $l . '<br>';
      if (isset($freq) && $freq != 'INF' && $class != 'white' && $class != 'lightgray') {
        $output .= intval($freq) . 'Hz<br>' . $kay . '</td>';
      }
      elseif (isset($freq) && $freq == 'INF') {
        $output .= 'INF</td>';
      }
      else {
        $output .= '-<br>-</td>';
      }
    }
    $output .= '</tr>';
  }
  $output .= '</table>';

  $output .= $rd2;


  $output .= '<h3>Lambdoma Keyboard (<a href="http://lambdoma.com" target="_blank">Barbara Hero</a>) colored in with the locally determined frequency , and the letter note values based on a 256Hz C.</h3><table><tr><th></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th><th>16</th></tr>';
  for ($u=0; $u<=16; $u++) {
    $output .= '<tr>';
    $output .= '<td>' . $u . '</td>';


    for ($l = 0; $l <= 16; $l++) {
      $class = 'white';
      foreach ($map as $n => $unexploded) {
        $exploded = explode(':', $unexploded);
        if ($exploded[0] == $l && $exploded[1] == $u && !empty($explode[2])) {
          $np = 'b' . $n;
          if ($n >= $tone ) {
            $np = $n - $tone;
            $np = 'f' . $np;
          }
          $class = $exploded[2];
          $freq = $exploded[3];
          $kay = $exploded[4] . ':' . $np;
          //$output .= '<td>' . $u . '</td>';
        }
        if ($class == 'white') {
          if ($l == 0) {
            $class = 'lightgray';
          }
          elseif ($u == 0) {
            $class = 'lightgray';
          }
        }
      }
      $output .= '<td class ="' . $class . '">' . $u . '/' . $l . '<br>';
      if (isset($freq) && $freq != 'INF' && $class != 'white' && $class != 'lightgray') {
        $output .= intval($freq) . 'Hz<br>' . $kay . '</td>';
      }
      elseif (isset($freq) && $freq == 'INF') {
        $output .= 'INF</td>';
      }
      else {
        $output .= '-<br>-</td>';
      }
    }
    $output .= '</tr>';
  }
  $output .= '</table>';

  //dpm($note_assembly);

  return $output;
}


// BOOKMARK: OUTPUT BLOCKS

function jellomatrix_output_splicegrid_derivative_harmonics($increment_original, $harmonics, $primes, $tone, $interval, $frequency, $print) {

  $note_assembly = [];
  $lambdoma_map = [];
  $output = '';

  // PRIMARY MATRIX DERIVATIVES.

  // Increment_PRIME: with the prime_matrix grid and the prime_increments variable.

  // First output the original harmonics with $columns and $rows.
  // Now output the differences between different integers.
  $note_order = [];
  $output .= '<div class="endtable begintext"><h2>PRIMES: Differences and Harmonics</h2>';
  $output .= '<p>The bold letters at the end of each row represent the Lambdona Notes that the ratios of repeating increment_prime_original create.</p><div class="endtext"><br></div>';
  foreach($increment_original as $k=>$increment_prime) {
    if ($k == 'rldiag') {
      $r = '<h3>Row</h3>';
      foreach ($increment_prime as $ke=>$direction) {
        if ($ke == 'forward') {
          unset($note_order);
          $r .= '<h4>Forward (Primes) (x,y)|(x+1,y)</h4>';
          $count = 1;
          $r .= '<table class="table"><tr>';
          foreach ($direction as $row) {
            $r .= '<td class="tdgridltfirst">Row ' . $count .': </td>';
            foreach ($row as $key=>$item) {
              if (in_array($item, $primes)) {
                $r .= '<td class="tdgrid subhighlight">' . $item . '</td>';
              }
              if (!in_array($item, $primes)) {
                $r .= '<td class="tdgrid">' . $item . '</td>';
              }
              if ($key == 0) {
                $zero = $item;
              }
              if ($key == 1) {
                $one = $item;
              }
              if ($key == 2) {
                $two = $item;
              }
              if ($key == 3) {
                $three = $item;
              }
            }
            if (isset($two) && isset($zero) && $zero == $two) {
              $upper = $zero;
            }
            else {
              unset($upper);
            }
            if (isset($three) && $one == $three) {
              $lower = $one;
            }
            else {
              unset($lower);
            }

            if (isset($upper)) {

              foreach ($harmonics as $note) {
                $explode = explode(':', $note);
                if (isset($lower) && $explode[0] == $upper && $explode[1] == $lower && !empty($explode[2])) {
                  $r .= '<td class="tdgrid"><strong>' . $explode[2] . '</strong></td>';
                  $note_order[]= $explode[3];
                  $lower = (int)$lower;
                  $upper = (int)$upper; $added = $upper+$lower;
                  if (is_numeric($upper) && is_numeric($lower)) {
                    $r .= '<td>' . $upper . '+' . $lower . '=<strong>' . $added . '</strong></td>';
                  }
                  $lambdoma_map[$k][$ke][$key][$count]['lower'] = $explode[0];
                  $lambdoma_map[$k][$ke][$key][$count]['upper'] = $explode[1];
                  $lambdoma_map[$k][$ke][$key][$count]['key'] = $explode[2];
                  if ($explode[2] == 'origin') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'black';
                  }
                  if ($explode[2] == 'C') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zcee';
                  }
                  elseif ($explode[2] == 'C#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zceesharp';
                  }
                  elseif ($explode[2] == 'D') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zdee';
                  }
                  elseif ($explode[2] == 'Eb') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zeeeflat';
                  }
                  elseif ($explode[2] == 'E') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zeee';
                  }
                  elseif ($explode[2] == 'F') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zeff';
                  }
                  elseif ($explode[2] == 'F#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zeffsharp';
                  }
                  elseif ($explode[2] == 'G') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zgee';
                  }
                  elseif ($explode[2] == 'G#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zgeesharp';
                  }
                  elseif ($explode[2] == 'A') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zay';
                  }
                  elseif ($explode[2] == 'Bb') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zbeeflat';
                  }
                  elseif ($explode[2] == 'B') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zbee';
                  }
                  else {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'darkslategray';
                  }
                  if (isset($explode[3])) {
                    $lambdoma_map[$k][$ke][$key][$count]['frequency'] = $explode[3];
                  }
                }
              }
            }
            $r .= '</tr>';
            $count++;
          }
          $r .= '</table>';
          $r .= '<h3>Order of frequencies: based on a ' . $frequency . 'Hz baseline or "C"</h3><ol>';
          if (isset($note_order)) {
            foreach ($note_order as $key => $hz) {

              $r .= '<li>' . $hz . 'Hz</li>';
            }
          }
          $r .= '</ol><hr>';
          $r .= '<div class="endtext"><br></div>';
          if (isset($note_order)) {
            $note_assembly[$ke]['r'][] = $note_order;
          }
        }
        if ($ke == 'backward') {
          unset($note_order);
          $rd = '<h4>Backward (Primes) (x,y)|(x-1,y)</h4>';
          $count = 1;
          $rd .= '<table class="table"><tr>';
          foreach ($direction as $row) {
            $rd .= '<td class="tdgridltfirst">Row ' . $count .': </td>';
            foreach ($row as $key=>$item) {
              if (in_array($item, $primes)) {
                $rd .= '<td class="tdgrid subhighlight">' . $item . '</td>';
              }
              if (!in_array($item, $primes)) {
                $rd .= '<td class="tdgrid">' . $item . '</td>';
              }
              if ($key == 0) {
                $zero = $item;
              }
              if ($key == 1) {
                $one = $item;
              }
              if ($key == 2) {
                $two = $item;
              }
              if ($key == 3) {
                $three = $item;
              }
            }
            if (isset($two) && isset($zero) && $zero == $two) {
              $upper = $zero;
            }
            else {
              unset($upper);
            }
            if (isset($three) && $one == $three) {
              $lower = $one;
            }
            else {
              unset($lower);
            }

            if (isset($upper)) {

              foreach ($harmonics as $note) {
                $explode = explode(':', $note);
                if (isset($lower) && $explode[0] == $upper && $explode[1] == $lower && !empty($explode[2])) {
                  $rd .= '<td class="tdgrid"><strong>' . $explode[2] . '</strong></td>';
                  $note_order[]= $explode[3];
                  $lower = (int)$lower;
                  $upper = (int)$upper; $added = $upper+$lower;
                  if (is_numeric($upper) && is_numeric($lower)) {
                    $rd .= '<td>' . $upper . '+' . $lower . '=<strong>' . $added . '</strong></td>';
                  }
                  $lambdoma_map[$k][$ke][$key][$count]['lower'] = $explode[0];
                  $lambdoma_map[$k][$ke][$key][$count]['upper'] = $explode[1];
                  $lambdoma_map[$k][$ke][$key][$count]['key'] = $explode[2];
                  if ($explode[2] == 'origin') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'black';
                  }
                  if ($explode[2] == 'C') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'cee';
                  }
                  elseif ($explode[2] == 'C#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'ceesharp';
                  }
                  elseif ($explode[2] == 'D') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'dee';
                  }
                  elseif ($explode[2] == 'Eb') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'eeeflat';
                  }
                  elseif ($explode[2] == 'E') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'eee';
                  }
                  elseif ($explode[2] == 'F') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'eff';
                  }
                  elseif ($explode[2] == 'F#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'effsharp';
                  }
                  elseif ($explode[2] == 'G') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'gee';
                  }
                  elseif ($explode[2] == 'G#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'geesharp';
                  }
                  elseif ($explode[2] == 'A') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'ay';
                  }
                  elseif ($explode[2] == 'Bb') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'beeflat';
                  }
                  elseif ($explode[2] == 'B') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'bee';
                  }
                  else {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'darkslategray';
                  }
                  if (isset($explode[3])) {
                    $lambdoma_map[$k][$ke][$key][$count]['frequency'] = $explode[3];
                  }
                }
              }
            }
            $rd .= '</tr>';
            $count++;
          }
          $rd .= '</table>';
          $rd .= '<h3>Order of frequencies: based on a ' . $frequency . 'Hz baseline or "C"</h3><ol>';
          if (isset($note_order)) {
            foreach ($note_order as $key => $hz) {

              $rd .= '<li>' . $hz . 'Hz</li>';
            }
          }
          $rd .= '</ol><hr>';
          $rd .= '<div class="endtext"><br></div>';
          if (isset($note_order)) {
            $note_assembly[$ke]['rd'][] = $note_order;
          }
        }
      }
    }
    if ($k == 'row') {
      $lr = '<h3>Left to Right Diagonals across a Row</h3>';
      foreach ($increment_prime as $ke=>$direction) {
        if ($ke == 'forward') {
          unset($note_order);
          $lr .= '<h4>Forward (Odd/Even) (x,y)|(x+1,y+1)</h4>';
          $count = 1;
          $lr .= '<table class="table"><tr>';
          foreach ($direction as $row) {
            $lr .= '<td class="tdgridlt">LR Row ' . $count .': </td>';
            foreach ($row as $key=>$item) {
              $test = $row;
              unset($clink); $clink = '';
              if (is_array($test)) {
                $a = array_pop($test);
                $b = array_pop($test);

                if (is_numeric($a) && ($a) % 2 == 0 && ($b) % 2 == 0) {
                  $clink = 'highlight';
                }
                elseif (is_numeric($a) && ($a) % 2 != 0 && ($b) % 2 != 0) {
                  $clink = 'highlight';
                }
              }
              if (isset($clink) && $clink == 'highlight') {
                $lr .= '<td class="tdgrid highlight">' . $item . '</td>';
              }
              elseif (($item) % 2 == 0) {
                $lr .= '<td class="tdgrid subhighlight">' . $item . '</td>';
              }
              elseif (($item) % 2 != 0) {
                $lr .= '<td class="tdgrid">' . $item . '</td>';
              }
              if ($key == 0) {
                $zero = $item;
              }
              if ($key == 1) {
                $one = $item;
              }
              if ($key == 2) {
                $two = $item;
              }
              if ($key == 3) {
                $three = $item;
              }
            }
            if (isset($two) && isset($zero) && $zero == $two) {
              $upper = $zero;
            }
            else {
              unset($upper);
            }
            if (isset($three) && $one == $three) {
              $lower = $one;
            }
            else {
              unset($lower);
            }

            if (isset($upper)) {

              foreach ($harmonics as $note) {
                $explode = explode(':', $note);
                if (isset($lower) && $explode[0] == $upper && $explode[1] == $lower && !empty($explode[2])) {
                  $lr .= '<td class="tdgrid"><strong>' . $explode[2] . '</strong></td>';
                  $note_order[]= $explode[3];
                  $lower = (int)$lower;
                  $upper = (int)$upper; $added = $upper+$lower;
                  if (is_numeric($upper) && is_numeric($lower)) {
                    $lr .= '<td>' . $upper . '+' . $lower . '=<strong>' . $added . '</strong></td>';
                  }
                  $lambdoma_map[$k][$ke][$key][$count]['lower'] = $explode[0];
                  $lambdoma_map[$k][$ke][$key][$count]['upper'] = $explode[1];
                  $lambdoma_map[$k][$ke][$key][$count]['key'] = $explode[2];
                  if ($explode[2] == 'origin') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'black';
                  }
                  if ($explode[2] == 'C') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zcee';
                  }
                  elseif ($explode[2] == 'C#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zceesharp';
                  }
                  elseif ($explode[2] == 'D') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zdee';
                  }
                  elseif ($explode[2] == 'Eb') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zeeeflat';
                  }
                  elseif ($explode[2] == 'E') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zeee';
                  }
                  elseif ($explode[2] == 'F') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zeff';
                  }
                  elseif ($explode[2] == 'F#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zeffsharp';
                  }
                  elseif ($explode[2] == 'G') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zgee';
                  }
                  elseif ($explode[2] == 'G#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zgeesharp';
                  }
                  elseif ($explode[2] == 'A') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zay';
                  }
                  elseif ($explode[2] == 'Bb') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zbeeflat';
                  }
                  elseif ($explode[2] == 'B') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zbee';
                  }
                  else {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'darkslategray';
                  }
                  if (isset($explode[3])) {
                    $lambdoma_map[$k][$ke][$key][$count]['frequency'] = $explode[3];
                  }
                }
              }
            }
            $lr .= '</tr>';
            $count++;
          }
          $lr .= '</table>';
          $lr .= '<h3>Order of frequencies: based on a ' . $frequency . 'Hz baseline or "C"</h3><ol>';
          if (isset($note_order)) {
            foreach ($note_order as $key => $hz) {

              $lr .= '<li>' . $hz . 'Hz</li>';
            }
          }
          $lr .= '</ol><hr>';
          $lr .= '<div class="endtext"><br></div>';
          if (isset($note_order)) {
            $note_assembly[$ke]['lr'][] = $note_order;
          }
        }
        if ($ke == 'backward') {
          unset($note_order);
          $lrd = '<h4>Backward (x,y)|(x-1,y-1)</h4>';
          $count = 1;
          $lrd .= '<table class="table"><tr>';
          foreach ($direction as $row) {
            $lrd .= '<td class="tdgridlt">LR Row ' . $count .': </td>';
            foreach ($row as $key=>$item) {
              $test = $row;
              unset($clink); $clink = '';
              if (is_array($test)) {
                $a = array_pop($test);
                $b = array_pop($test);

                if (is_numeric($a) && ($a) % 2 == 0 && ($b) % 2 == 0) {
                  $clink = 'highlight';
                }
                elseif (is_numeric($a) && ($a) % 2 != 0 && ($b) % 2 != 0) {
                  $clink = 'highlight';
                }
              }
              if (isset($clink) && $clink == 'highlight') {
                $lrd .= '<td class="tdgrid highlight">' . $item . '</td>';
              }
              elseif (($item) % 2 == 0) {
                $lrd .= '<td class="tdgrid subhighlight">' . $item . '</td>';
              }
              elseif (($item) % 2 != 0) {
                $lrd .= '<td class="tdgrid">' . $item . '</td>';
              }
              if ($key == 0) {
                $zero = $item;
              }
              if ($key == 1) {
                $one = $item;
              }
              if ($key == 2) {
                $two = $item;
              }
              if ($key == 3) {
                $three = $item;
              }
            }
            if (isset($two) && isset($zero) && $zero == $two) {
              $upper = $zero;
            }
            else {
              unset($upper);
            }
            if (isset($three) && $one == $three) {
              $lower = $one;
            }
            else {
              unset($lower);
            }

            if (isset($upper)) {

              foreach ($harmonics as $note) {
                $explode = explode(':', $note);
                if (isset($lower) && $explode[0] == $upper && $explode[1] == $lower && !empty($explode[2])) {
                  $lrd .= '<td class="tdgrid"><strong>' . $explode[2] . '</strong></td>';
                  $note_order[]= $explode[3];
                  $lower = (int)$lower;
                  $upper = (int)$upper; $added = $upper+$lower;
                  if (is_numeric($upper) && is_numeric($lower)) {
                    $lrd .= '<td>' . $upper . '+' . $lower . '=<strong>' . $added . '</strong></td>';
                  }
                  $lambdoma_map[$k][$ke][$key][$count]['lower'] = $explode[0];
                  $lambdoma_map[$k][$ke][$key][$count]['upper'] = $explode[1];
                  $lambdoma_map[$k][$ke][$key][$count]['key'] = $explode[2];
                  if ($explode[2] == 'origin') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'black';
                  }
                  if ($explode[2] == 'C') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'cee';
                  }
                  elseif ($explode[2] == 'C#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'ceesharp';
                  }
                  elseif ($explode[2] == 'D') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'dee';
                  }
                  elseif ($explode[2] == 'Eb') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'eeeflat';
                  }
                  elseif ($explode[2] == 'E') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'eee';
                  }
                  elseif ($explode[2] == 'F') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'eff';
                  }
                  elseif ($explode[2] == 'F#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'effsharp';
                  }
                  elseif ($explode[2] == 'G') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'gee';
                  }
                  elseif ($explode[2] == 'G#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'geesharp';
                  }
                  elseif ($explode[2] == 'A') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'ay';
                  }
                  elseif ($explode[2] == 'Bb') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'beeflat';
                  }
                  elseif ($explode[2] == 'B') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'bee';
                  }
                  else {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'darkslategray';
                  }
                  if (isset($explode[3])) {
                    $lambdoma_map[$k][$ke][$key][$count]['frequency'] = $explode[3];
                  }
                }
              }
            }
            $lrd .= '</tr>';
            $count++;
          }
          $lrd .= '</table>';
          $lrd .= '<h3>Order of frequencies: based on a ' . $frequency . 'Hz baseline or "C"</h3><ol>';
          if (isset($note_order)) {
            foreach ($note_order as $key => $hz) {

              $lrd .= '<li>' . $hz . 'Hz</li>';
            }
          }
          $lrd .= '</ol><hr>';
          $lrd .= '<div class="endtext"><br></div>';
          if (isset($note_order)) {
            $note_assembly[$ke]['lrd'][] = $note_order;
          }
        }
      }
    }
    if ($k == 'lrdiag') {
      $rl = '<h3>Right to Left Diagonals across a Row</h3>';
      foreach ($increment_prime as $ke=>$direction) {
        if ($ke == 'forward') {
          unset($note_order);
          $rl .= '<h4>Forward (Primes) (x,y)|(x+1,y-1)</h4>';
          $count = 1;
          $rl .= '<table class="table"><tr>';
          foreach ($direction as $row) {
            $rl .= '<td class="tdgridlt">RL Row ' . $count .': </td>';
            foreach ($row as $key=>$item) {
              if (in_array($item, $primes)) {
                $rl .= '<td class="tdgrid subhighlight">' . $item . '</td>';
              }
              if (!in_array($item, $primes)) {
                $rl .= '<td class="tdgrid">' . $item . '</td>';
              }
              if ($key == 0) {
                $zero = $item;
              }
              if ($key == 1) {
                $one = $item;
              }
              if ($key == 2) {
                $two = $item;
              }
              if ($key == 3) {
                $three = $item;
              }
            }
            if (isset($two) && isset($zero) && $zero == $two) {
              $upper = $zero;
            }
            else {
              unset($upper);
            }
            if (isset($three) && $one == $three) {
              $lower = $one;
            }
            else {
              unset($lower);
            }

            if (isset($upper)) {

              foreach ($harmonics as $note) {
                $explode = explode(':', $note);
                if (isset($lower) && $explode[0] == $upper && $explode[1] == $lower && !empty($explode[2])) {
                  $rl .= '<td class="tdgrid"><strong>' . $explode[2] . '</strong></td>';
                  $note_order[]= $explode[3];
                  $lower = (int)$lower;
                  $upper = (int)$upper; $added = $upper+$lower;
                  if (is_numeric($upper) && is_numeric($lower)) {
                    $rl .= '<td>' . $upper . '+' . $lower . '=<strong>' . $added . '</strong></td>';
                  }
                  $lambdoma_map[$k][$ke][$key][$count]['lower'] = $explode[0];
                  $lambdoma_map[$k][$ke][$key][$count]['upper'] = $explode[1];
                  $lambdoma_map[$k][$ke][$key][$count]['key'] = $explode[2];
                  if ($explode[2] == 'origin') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'black';
                  }
                  if ($explode[2] == 'C') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zcee';
                  }
                  elseif ($explode[2] == 'C#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zceesharp';
                  }
                  elseif ($explode[2] == 'D') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zdee';
                  }
                  elseif ($explode[2] == 'Eb') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zeeeflat';
                  }
                  elseif ($explode[2] == 'E') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zeee';
                  }
                  elseif ($explode[2] == 'F') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zeff';
                  }
                  elseif ($explode[2] == 'F#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zeffsharp';
                  }
                  elseif ($explode[2] == 'G') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zgee';
                  }
                  elseif ($explode[2] == 'G#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zgeesharp';
                  }
                  elseif ($explode[2] == 'A') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zay';
                  }
                  elseif ($explode[2] == 'Bb') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zbeeflat';
                  }
                  elseif ($explode[2] == 'B') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zbee';
                  }
                  else {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'darkslategray';
                  }
                  if (isset($explode[3])) {
                    $lambdoma_map[$k][$ke][$key][$count]['frequency'] = $explode[3];
                  }
                }
              }
            }
            $rl .= '</tr>';
            $count++;
          }
          $rl .= '</table>';
          $rl .= '<h3>Order of frequencies: based on a ' . $frequency . 'Hz baseline or "C"</h3><ol>';
          if (isset($note_order)) {
            foreach ($note_order as $key => $hz) {

              $rl .= '<li>' . $hz . 'Hz</li>';
            }
          }
          $rl .= '</ol><hr>';
          $rl .= '<div class="endtext"><br></div>';
          if (isset($note_order)) {
            $note_assembly[$ke]['rl'][] = $note_order;
          }
        }
        if ($ke == 'backward') {
          unset($note_order);
          $rld = '<h4>Backward (Primes) (x,y)|(x-1,y+1)</h4>';
          $count = 1;
          $rld .= '<table class="table"><tr>';
          foreach ($direction as $row) {
            $rld .= '<td class="tdgridlt">RL Row ' . $count .': </td>';
            foreach ($row as $key=>$item) {
              if (in_array($item, $primes)) {
                $rld .= '<td class="tdgrid subhighlight">' . $item . '</td>';
              }
              if (!in_array($item, $primes)) {
                $rld .= '<td class="tdgrid">' . $item . '</td>';
              }
              if ($key == 0) {
                $zero = $item;
              }
              if ($key == 1) {
                $one = $item;
              }
              if ($key == 2) {
                $two = $item;
              }
              if ($key == 3) {
                $three = $item;
              }
            }
            if (isset($two) && isset($zero) && $zero == $two) {
              $upper = $zero;
            }
            else {
              unset($upper);
            }
            if (isset($three) && $one == $three) {
              $lower = $one;
            }
            else {
              unset($lower);
            }

            if (isset($upper)) {
              foreach ($harmonics as $note) {

                $explode = explode(':', $note);
                if (isset($lower) && $explode[0] == $upper && $explode[1] == $lower && !empty($explode[2])) {
                  $rld .= '<td class="tdgrid"><strong>' . $explode[2] . '</strong></td>';
                  $note_order[]= $explode[3];
                  $lower = (int)$lower;
                  $upper = (int)$upper; $added = $upper+$lower;
                  if (is_numeric($upper) && is_numeric($lower)) {
                    $rld .= '<td>' . $upper . '+' . $lower . '=<strong>' . $added . '</strong></td>';
                  }
                  $lambdoma_map[$k][$ke][$key][$count]['lower'] = $explode[0];
                  $lambdoma_map[$k][$ke][$key][$count]['upper'] = $explode[1];
                  $lambdoma_map[$k][$ke][$key][$count]['key'] = $explode[2];
                  if ($explode[2] == 'origin') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'black';
                  }
                  if ($explode[2] == 'C') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'cee';
                  }
                  elseif ($explode[2] == 'C#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'ceesharp';
                  }
                  elseif ($explode[2] == 'D') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'dee';
                  }
                  elseif ($explode[2] == 'Eb') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'eeeflat';
                  }
                  elseif ($explode[2] == 'E') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'eee';
                  }
                  elseif ($explode[2] == 'F') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'eff';
                  }
                  elseif ($explode[2] == 'F#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'effsharp';
                  }
                  elseif ($explode[2] == 'G') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'gee';
                  }
                  elseif ($explode[2] == 'G#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'geesharp';
                  }
                  elseif ($explode[2] == 'A') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'ay';
                  }
                  elseif ($explode[2] == 'Bb') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'beeflat';
                  }
                  elseif ($explode[2] == 'B') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'bee';
                  }
                  else {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'darkslategray';
                  }
                  if (isset($explode[3])) {
                    $lambdoma_map[$k][$ke][$key][$count]['frequency'] = $explode[3];
                  }
                }
              }
            }
            $rld .= '</tr>';
            $count++;
          }
          $rld .= '</table>';
          $rld .= '<h3>Order of frequencies: based on a ' . $frequency . 'Hz baseline or "C"</h3><ol>';
          if (isset($note_order)) {
            foreach ($note_order as $key => $hz) {

              $rld .= '<li>' . $hz . 'Hz</li>';
            }
          }
          $rld .= '</ol><hr>';
          $rld .= '<div class="endtext"><br></div>';
          if (isset($note_order)) {
            $note_assembly[$ke]['rld'][] = $note_order;
          }
        }
      }
    }
  }
  $output .= $r;
  $output .= $rd;


  /*$output .= '<table><tr><th>k</th><th>ke</th><th>key</th><th>row</th><th>note</th><th>lower</th><th>upper</th></tr>';
  foreach($lambdoma_map as $k => $data) {
    foreach($data as $ke => $stuff) {
      foreach ($stuff as $key => $counts) {
        foreach ($counts as $count => $values) {
          $output .= "<tr><td>" . $k . "</td><td>" . $ke . "</td><td>" . $key . "</td><td>" . $count . "</td><td>" . $values['key'] . "</td><td>" . $values['lower'] . "</td><td>" . $values['upper'] . "</td></tr>";
        }
      }
    }
  }
  $output .= "</table>";*/

  $map = [];
  foreach ($lambdoma_map as $k => $data) {
    foreach ($data as $ke => $stuff) {
      //if ($ke = 'forward' || $k = 'row') {*/
      foreach ($stuff as $key => $counts) {
        foreach ($counts as $count => $values) {
          for ($u = 0; $u <= 16; $u++) {
            for ($l = 0; $l <= 16; $l++) {
              if (!in_array($values['upper'] . ':' . $values['lower'] . ':' . $values['class'] . ':' . $values['frequency'] . ':' . $values['key'], $map)) {
                $map[] = $values['upper'] . ':' . $values['lower'] . ':' . $values['class'] . ':' . $values['frequency'] . ':' . $values['key'];
              }
            }
          }
        }
      }
      //}
    }
  }


  $output .= '<h3>Lambdoma Keyboard (<a href="http://lambdoma.com" target="_blank">Barbara Hero</a>) colored in with the locally determined frequency , and the letter note values based on a 256Hz C.</h3><table><tr><th></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th><th>16</th></tr>';
  for ($u=0; $u<=16; $u++) {
    $output .= '<tr>';
    $output .= '<td>' . $u . '</td>';


    for ($l = 0; $l <= 16; $l++) {
      $class = 'white';
      foreach ($map as $n => $unexploded) {
        $exploded = explode(':', $unexploded);
        if ($exploded[0] == $l && $exploded[1] == $u && !empty($explode[2])) {
          $np = 'b' . $n;
          if ($n >= $tone ) {
            $np = $n - $tone;
            $np = 'f' . $np;
          }
          $class = $exploded[2];
          $freq = $exploded[3];
          $kay = $exploded[4] . ':' . $np;
          //$output .= '<td>' . $u . '</td>';
        }
        if ($class == 'white') {
          if ($l == 0) {
            $class = 'lightgray';
          }
          elseif ($u == 0) {
            $class = 'lightgray';
          }
        }
      }
      $output .= '<td class ="' . $class . '">' . $u . '/' . $l . '<br>';
      if (isset($freq) && $freq != 'INF' && $class != 'white' && $class != 'lightgray') {
        $output .= intval($freq) . 'Hz<br>' . $kay . '</td>';
      }
      elseif (isset($freq) && $freq == 'INF') {
        $output .= 'INF</td>';
      }
      else {
        $output .= '-<br>-</td>';
      }
    }
    $output .= '</tr>';
  }
  $output .= '</table>';

  $output .= $rl;
  $output .= $rld;


  $output .= '<h3>Lambdoma Keyboard (<a href="http://lambdoma.com" target="_blank">Barbara Hero</a>) colored in with the locally determined frequency , and the letter note values based on a 256Hz C.</h3><table><tr><th></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th><th>16</th></tr>';
  for ($u=0; $u<=16; $u++) {
    $output .= '<tr>';
    $output .= '<td>' . $u . '</td>';


    for ($l = 0; $l <= 16; $l++) {
      $class = 'white';
      foreach ($map as $n => $unexploded) {
        $exploded = explode(':', $unexploded);
        if ($exploded[0] == $l && $exploded[1] == $u && !empty($explode[2])) {
          $np = 'b' . $n;
          if ($n >= $tone ) {
            $np = $n - $tone;
            $np = 'f' . $np;
          }
          $class = $exploded[2];
          $freq = $exploded[3];
          $kay = $exploded[4] . ':' . $np;
          //$output .= '<td>' . $u . '</td>';
        }
        if ($class == 'white') {
          if ($l == 0) {
            $class = 'lightgray';
          }
          elseif ($u == 0) {
            $class = 'lightgray';
          }
        }
      }
      $output .= '<td class ="' . $class . '">' . $u . '/' . $l . '<br>';
      if (isset($freq) && $freq != 'INF' && $class != 'white' && $class != 'lightgray') {
        $output .= intval($freq) . 'Hz<br>' . $kay . '</td>';
      }
      elseif (isset($freq) && $freq == 'INF') {
        $output .= 'INF</td>';
      }
      else {
        $output .= '-<br>-</td>';
      }
    }
    $output .= '</tr>';
  }
  $output .= '</table>';

  $output .= $lr;
  $output .= $lrd;


  $output .= '<h3>Lambdoma Keyboard (<a href="http://lambdoma.com" target="_blank">Barbara Hero</a>) colored in with the locally determined frequency , and the letter note values based on a 256Hz C.</h3><table><tr><th></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th><th>16</th></tr>';
  for ($u=0; $u<=16; $u++) {
    $output .= '<tr>';
    $output .= '<td>' . $u . '</td>';


    for ($l = 0; $l <= 16; $l++) {
      $class = 'white';
      foreach ($map as $n => $unexploded) {
        $exploded = explode(':', $unexploded);
        if ($exploded[0] == $l && $exploded[1] == $u && !empty($explode[2])) {
          $np = 'b' . $n;
          if ($n >= $tone ) {
            $np = $n - $tone;
            $np = 'f' . $np;
          }
          $class = $exploded[2];
          $freq = $exploded[3];
          $kay = $exploded[4] . ':' . $np;
          //$output .= '<td>' . $u . '</td>';
        }
        if ($class == 'white') {
          if ($l == 0) {
            $class = 'lightgray';
          }
          elseif ($u == 0) {
            $class = 'lightgray';
          }
        }
      }
      $output .= '<td class ="' . $class . '">' . $u . '/' . $l . '<br>';
      if (isset($freq) && $freq != 'INF' && $class != 'white' && $class != 'lightgray') {
        $output .= intval($freq) . 'Hz<br>' . $kay . '</td>';
      }
      elseif (isset($freq) && $freq == 'INF') {
        $output .= 'INF</td>';
      }
      else {
        $output .= '-<br>-</td>';
      }
    }
    $output .= '</tr>';
  }
  $output .= '</table>';

  $output .= '<hr class="hr">';

  //dpm($note_assembly);$output .= '</div><hr class="hr"><br>';

  $output .= '<h2>Solving for the 3D: extrapolating the matrix into 3 dimensions creating a fabric that is infinitely scalable in 6 directions: a sample using waveform pairs form the 13/20 matrix:</h2>';
  $output .= '<img src="/sites/default/files/2019-07/jellomatrix_1320_3d_0.png" width="100%" height="auto" /><hr>';

  $output .= '<div class="begintext"><p><a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png" /></a><br /><span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/InteractiveResource" property="dct:title" rel="dct:type">Jellomatrix</span> by <a xmlns:cc="http://creativecommons.org/ns#" href="https://www.jellobrain.com" property="cc:attributionName" rel="cc:attributionURL">Ana Willem</a> is licensed since 2007 under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License</a>.<br />Based on a work at <a xmlns:dct="http://purl.org/dc/terms/" href="https://www.jellobrain.com" rel="dct:source">https://www.jellobrain.com</a>.</p></div><hr class="hr">';



  return $output;
}


// BOOKMARK: OUTPUT BLOCKS

function jellomatrix_output_splicegrid_derivative_oddeven($increments_prime, $primes, $tone, $interval, $harmonics, $frequency, $print) {
  $lambdoma_map = [];
  $note_assembly = [];
  $output = '';
  // Now output the differences between different integers.
  $output .= '<div class="endtable begintext"><h2>PRIMARY MATRIX DERIVATIVES ODD+EVEN: Derivatives</h2>';
  $output .= '<p>The bold letters at the end of each row represent the Lambdona Notes that the ratios of repeating PRIMARY MATRIX increments create.</p><div class="endtext"><br></div>';

  foreach($increments_prime as $k=>$increment_prime) {
    if ($k == 'row') {
      $r = '<h3>PRIME (Odd/Even): Original Matrix</h3>';
      foreach ($increment_prime as $ke=>$direction) {
        if ($ke == 'forward') {
          $r .= '';
          $r .= '<p></p><div class="endtext"><br></div>';
          $count = 1;
          $r .= '<table class="table"><tr>';
          foreach ($direction as $prime_row) {
            $r .= '<td class="tdgridltfirst">Row ' . $count .': </td>';
            foreach ($prime_row as $key=>$item) {
              $test = $prime_row;
              unset($clink); $clink = '';
              if (is_array($test)) {
                $a = array_pop($test);
                $b = array_pop($test);

                if (is_numeric($a) && ($a) % 2 == 0 && ($b) % 2 == 0) {
                  $clink = 'highlight';
                }
                elseif (is_numeric($a) && ($a) % 2 != 0 && ($b) % 2 != 0) {
                  $clink = 'highlight';
                }
              }
              if (isset($clink) && $clink == 'highlight') {
                $r .= '<td class="tdgrid highlight">' . $item . '</td>';
              }
              elseif (($item) % 2 == 0) {
                $r .= '<td class="tdgrid subhighlight">' . $item . '</td>';
              }
              elseif (($item) % 2 != 0) {
                $r .= '<td class="tdgrid">' . $item . '</td>';
              }
              if ($key == 0) {
                $zero = $item;
              }
              if ($key == 1) {
                $one = $item;
              }
              if ($key == 2) {
                $two = $item;
              }
              if ($key == 3) {
                $three = $item;
              }
              if ($key == 4) {
                $four = $item;
              }
            }

            if (isset($three) && isset($one) && $three == $one) {
              $upper = $one;
            } else {
              unset($upper);
            }
            if (isset($four) && $two == $four) {
              $lower = $two;
            } else {
              unset($lower);
            }


            if (isset($upper)) {
              foreach ($harmonics as $note) {

                $explode = explode(':', $note);
                if (isset($lower) && $explode[0] == $upper && $explode[1] == $lower && !empty($explode[2])) {
                  $r .= '<td class="tdgrid"><strong>' . $explode[2] . '</strong></td>';
                  $note_order[]= $explode[3];
                  $lower = (int)$lower;
                  $upper = (int)$upper; $added = $upper+$lower;
                  if (is_numeric($upper) && is_numeric($lower)) {
                    $r .= '<td>' . $upper . '+' . $lower . '=<strong>' . $added . '</strong></td>';
                  }
                  $lambdoma_map[$k][$ke][$key][$count]['lower'] = $explode[0];
                  $lambdoma_map[$k][$ke][$key][$count]['upper'] = $explode[1];
                  $lambdoma_map[$k][$ke][$key][$count]['key'] = $explode[2];
                  if ($explode[2] == 'origin') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'black';
                  }
                  if ($explode[2] == 'C') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zcee';
                  }
                  elseif ($explode[2] == 'C#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zceesharp';
                  }
                  elseif ($explode[2] == 'D') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zdee';
                  }
                  elseif ($explode[2] == 'Eb') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zeeeflat';
                  }
                  elseif ($explode[2] == 'E') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zeee';
                  }
                  elseif ($explode[2] == 'F') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zeff';
                  }
                  elseif ($explode[2] == 'F#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zeffsharp';
                  }
                  elseif ($explode[2] == 'G') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zgee';
                  }
                  elseif ($explode[2] == 'G#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zgeesharp';
                  }
                  elseif ($explode[2] == 'A') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zay';
                  }
                  elseif ($explode[2] == 'Bb') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zbeeflat';
                  }
                  elseif ($explode[2] == 'B') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zbee';
                  }
                  else {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'darkslategray';
                  }
                  if (isset($explode[3])) {
                    $lambdoma_map[$k][$ke][$key][$count]['frequency'] = $explode[3];
                  }
                }
              }
            }
            $r .= '</tr>';
            $count++;
          }
          $r .= '</table>';
          $r .= '<h3>Order of frequencies: based on a ' . $frequency . 'Hz baseline or "C"</h3><ol>';
          if (isset($note_order)) {
            foreach ($note_order as $key => $hz) {

              $r .= '<li>' . $hz . 'Hz</li>';
            }
          }
          $r .= '</ol><hr>';
          $r .= '<div class="endtext"><br></div>';
          if (isset($note_order)) {
            $note_assembly[$ke]['r'][] = $note_order;
          }
        }
        if ($ke == 'derivative') {
          unset($note_order);
          $rd = '<h4>First Derivative: (Odd/Even)</h4>';
          $count = 1;
          $rd .= '<table class="table"><tr>';
          foreach ($direction as $prime_row) {
            $rd .= '<td class="tdgridltfirst">Row ' . $count .': </td>';
            foreach ($prime_row as $key=>$item) {
              $test = $prime_row;
              unset($clink); $clink = '';
              if (is_array($test)) {
                $a = array_pop($test);
                $b = array_pop($test);

                if (is_numeric($a) && ($a) % 2 == 0 && ($b) % 2 == 0) {
                  $clink = 'highlight';
                }
                elseif (is_numeric($a) && ($a) % 2 != 0 && ($b) % 2 != 0) {
                  $clink = 'highlight';
                }
              }
              if (isset($clink) && $clink == 'highlight') {
                $rd .= '<td class="tdgrid highlight">' . $item . '</td>';
              }
              elseif (($item) % 2 == 0) {
                $rd .= '<td class="tdgrid subhighlight">' . $item . '</td>';
              }
              elseif (($item) % 2 != 0) {
                $rd .= '<td class="tdgrid">' . $item . '</td>';
              }
              if ($key == 0) {
                $zero = $item;
              }
              if ($key == 1) {
                $one = $item;
              }
              if ($key == 2) {
                $two = $item;
              }
              if ($key == 3) {
                $three = $item;
              }
              if ($key == 4) {
                $four = $item;
              }
            }

            if (isset($three) && isset($one) && $three == $one) {
              $upper = $one;
            } else {
              unset($upper);
            }
            if (isset($four) && $two == $four) {
              $lower = $two;
            } else {
              unset($lower);
            }


            if (isset($upper)) {

              foreach ($harmonics as $note) {
                $explode = explode(':', $note);
                if (isset($lower) && $explode[0] == $upper && $explode[1] == $lower && !empty($explode[2])) {
                  $rd .= '<td class="tdgrid"><strong>' . $explode[2] . '</strong></td>';
                  $note_order[]= $explode[3];
                  $lower = (int)$lower;
                  $upper = (int)$upper; $added = $upper+$lower;
                  if (is_numeric($upper) && is_numeric($lower)) {
                    $rd .= '<td>' . $upper . '+' . $lower . '=<strong>' . $added . '</strong></td>';
                  }
                  $lambdoma_map[$k][$ke][$key][$count]['lower'] = $explode[0];
                  $lambdoma_map[$k][$ke][$key][$count]['upper'] = $explode[1];
                  $lambdoma_map[$k][$ke][$key][$count]['key'] = $explode[2];
                  if ($explode[2] == 'origin') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'black';
                  }
                  if ($explode[2] == 'C') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'cee';
                  }
                  elseif ($explode[2] == 'C#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'ceesharp';
                  }
                  elseif ($explode[2] == 'D') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'dee';
                  }
                  elseif ($explode[2] == 'Eb') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'eeeflat';
                  }
                  elseif ($explode[2] == 'E') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'eee';
                  }
                  elseif ($explode[2] == 'F') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'eff';
                  }
                  elseif ($explode[2] == 'F#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'effsharp';
                  }
                  elseif ($explode[2] == 'G') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'gee';
                  }
                  elseif ($explode[2] == 'G#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'geesharp';
                  }
                  elseif ($explode[2] == 'A') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'ay';
                  }
                  elseif ($explode[2] == 'Bb') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'beeflat';
                  }
                  elseif ($explode[2] == 'B') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'bee';
                  }
                  else {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'darkslategray';
                  }
                  if (isset($explode[3])) {
                    $lambdoma_map[$k][$ke][$key][$count]['frequency'] = $explode[3];
                  }
                }
              }
            }
            $rd .= '</tr>';
            $count++;
          }
          $rd .= '</table>';
          $rd .= '<h3>Order of frequencies: based on a ' . $frequency . 'Hz baseline or "C"</h3><ol>';
          if (isset($note_order)) {
            foreach ($note_order as $key => $hz) {

              $rd .= '<li>' . $hz . 'Hz</li>';
            }
          }
          $rd .= '</ol><hr>';
          $rd .= '<div class="endtext"><br></div>';
          if (isset($note_order)) {
            $note_assembly[$ke]['rd'][] = $note_order;
          }
        }
        if ($ke == 'derivative_2') {
          unset($note_order);
          $rd2 = '<h4>Second Derivative: (Odd/Even)</h4>';
          $count = 1;
          $rd2 .= '<table class="table"><tr>';
          foreach ($direction as $prime_row) {
            $rd2 .= '<td class="tdgridltfirst">Row ' . $count .': </td>';
            foreach ($prime_row as $key=>$item) {
              $test = $prime_row;
              unset($clink); $clink = '';
              if (is_array($test)) {
                $a = array_pop($test);
                $b = array_pop($test);

                if (is_numeric($a) && ($a) % 2 == 0 && ($b) % 2 == 0) {
                  $clink = 'highlight';
                }
                elseif (is_numeric($a) && ($a) % 2 != 0 && ($b) % 2 != 0) {
                  $clink = 'highlight';
                }
              }
              if (isset($clink) && $clink == 'highlight') {
                $rd2 .= '<td class="tdgrid highlight">' . $item . '</td>';
              }
              elseif (($item) % 2 == 0) {
                $rd2 .= '<td class="tdgrid subhighlight">' . $item . '</td>';
              }
              elseif (($item) % 2 != 0) {
                $rd2 .= '<td class="tdgrid">' . $item . '</td>';
              }
              if ($key == 0) {
                $zero = $item;
              }
              if ($key == 1) {
                $one = $item;
              }
              if ($key == 2) {
                $two = $item;
              }
              if ($key == 3) {
                $three = $item;
              }
              if ($key == 4) {
                $four = $item;
              }
            }

            if (isset($three) && isset($one) && $three == $one) {
              $upper = $one;
            } else {
              unset($upper);
            }
            if (isset($four) && $two == $four) {
              $lower = $two;
            } else {
              unset($lower);
            }

            if (isset($upper)) {

              foreach ($harmonics as $note) {
                $explode = explode(':', $note);
                if (isset($lower) && $explode[0] == $upper && $explode[1] == $lower && !empty($explode[2])) {
                  $rd2 .= '<td class="tdgrid"><strong>' . $explode[2] . '</strong></td>';
                  $note_order[]= $explode[3];
                  $lower = (int)$lower;
                  $upper = (int)$upper; $added = $upper+$lower;
                  if (is_numeric($upper) && is_numeric($lower)) {
                    $rd2 .= '<td>' . $upper . '+' . $lower . '=<strong>' . $added . '</strong></td>';
                  }
                  $lambdoma_map[$k][$ke][$key][$count]['lower'] = $explode[0];
                  $lambdoma_map[$k][$ke][$key][$count]['upper'] = $explode[1];
                  $lambdoma_map[$k][$ke][$key][$count]['key'] = $explode[2];
                  if ($explode[2] == 'origin') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'black';
                  }
                  if ($explode[2] == 'C') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'cee';
                  }
                  elseif ($explode[2] == 'C#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'ceesharp';
                  }
                  elseif ($explode[2] == 'D') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'dee';
                  }
                  elseif ($explode[2] == 'Eb') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'eeeflat';
                  }
                  elseif ($explode[2] == 'E') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'eee';
                  }
                  elseif ($explode[2] == 'F') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'eff';
                  }
                  elseif ($explode[2] == 'F#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'effsharp';
                  }
                  elseif ($explode[2] == 'G') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'gee';
                  }
                  elseif ($explode[2] == 'G#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'geesharp';
                  }
                  elseif ($explode[2] == 'A') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'ay';
                  }
                  elseif ($explode[2] == 'Bb') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'beeflat';
                  }
                  elseif ($explode[2] == 'B') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'bee';
                  }
                  else {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'darkslategray';
                  }
                  if (isset($explode[3])) {
                    $lambdoma_map[$k][$ke][$key][$count]['frequency'] = $explode[3];
                  }
                }
              }
            }
            $rd2 .= '</tr>';
            $count++;
          }
          $rd2 .= '</table>';
          $rd2 .= '<h3>Order of frequencies: based on a ' . $frequency . 'Hz baseline or "C"</h3><ol>';
          if (isset($note_order)) {
            foreach ($note_order as $key => $hz) {

              $rd2 .= '<li>' . $hz . 'Hz</li>';
            }
          }
          $rd2 .= '</ol><hr>';
          $rd2 .= '<div class="endtext"><br></div>';
          if (isset($note_order)) {
            $note_assembly[$ke]['rd2'][] = $note_order;
          }
        }
      }
    }
  }
  $output .= $r;


  /*$output .= '<table><tr><th>k</th><th>ke</th><th>key</th><th>row</th><th>note</th><th>lower</th><th>upper</th></tr>';
  foreach($lambdoma_map as $k => $data) {
    foreach($data as $ke => $stuff) {
      foreach ($stuff as $key => $counts) {
        foreach ($counts as $count => $values) {
          $output .= "<tr><td>" . $k . "</td><td>" . $ke . "</td><td>" . $key . "</td><td>" . $count . "</td><td>" . $values['key'] . "</td><td>" . $values['lower'] . "</td><td>" . $values['upper'] . "</td></tr>";
        }
      }
    }
  }
  $output .= "</table>";*/

  $map = [];
  foreach ($lambdoma_map as $k => $data) {
    foreach ($data as $ke => $stuff) {
      //if ($ke = 'forward' || $k = 'row') {*/
      foreach ($stuff as $key => $counts) {
        foreach ($counts as $count => $values) {
          for ($u = 0; $u <= 16; $u++) {
            for ($l = 0; $l <= 16; $l++) {
              if (!in_array($values['upper'] . ':' . $values['lower'] . ':' . $values['class'] . ':' . $values['frequency'] . ':' . $values['key'], $map)) {
                $map[] = $values['upper'] . ':' . $values['lower'] . ':' . $values['class'] . ':' . $values['frequency'] . ':' . $values['key'];
              }
            }
          }
        }
      }
      //}
    }
  }


  $output .= '<h3>Lambdoma Keyboard (<a href="http://lambdoma.com" target="_blank">Barbara Hero</a>) colored in with the locally determined frequency , and the letter note values based on a 256Hz C.</h3><table><tr><th></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th><th>16</th></tr>';
  for ($u=0; $u<=16; $u++) {
    $output .= '<tr>';
    $output .= '<td>' . $u . '</td>';


    for ($l = 0; $l <= 16; $l++) {
      $class = 'white';
      foreach ($map as $n => $unexploded) {
        $exploded = explode(':', $unexploded);
        if ($exploded[0] == $l && $exploded[1] == $u && !empty($explode[2])) {
          $np = 'b' . $n;
          if ($n >= $tone ) {
            $np = $n - $tone;
            $np = 'f' . $np;
          }
          $class = $exploded[2];
          $freq = $exploded[3];
          $kay = $exploded[4] . ':' . $np;
          //$output .= '<td>' . $u . '</td>';
        }
        if ($class == 'white') {
          if ($l == 0) {
            $class = 'lightgray';
          }
          elseif ($u == 0) {
            $class = 'lightgray';
          }
        }
      }
      $output .= '<td class ="' . $class . '">' . $u . '/' . $l . '<br>';
      if (isset($freq) && $freq != 'INF' && $class != 'white' && $class != 'lightgray') {
        $output .= intval($freq) . 'Hz<br>' . $kay . '</td>';
      }
      elseif (isset($freq) && $freq == 'INF') {
        $output .= 'INF</td>';
      }
      else {
        $output .= '-<br>-</td>';
      }
    }
    $output .= '</tr>';
  }
  $output .= '</table>';

  if (isset($rd)) {
    $output .= $rd;
  }

  if (isset($rd2)) {
    $output .= $rd2;
  }


  $output .= '</div><hr class="hr"><br>';
  //dpm($note_assembly);
  return $output;
}


// BOOKMARK: OUTPUT BLOCKS

function jellomatrix_output_splicegrid_derivative_primes($increments_prime, $primes, $tone, $interval, $harmonics, $frequency, $print) {
  $lambdoma_map = [];
  $note_assembly = [];
  $note_order = [];

  $output = '';
  // Now output the differences between different integers.
  $output .= '<div class="endtable begintext"><h2>PRIMARY MATRIX DERIVATIVES PRIMES: Derivatives</h2>';
  $output .= '<p>The bold letters at the end of each row represent the Lambdona Notes that the ratios of repeating PRIMARY MATRIX increments create.</p><div class="endtext"><br></div>';

  foreach($increments_prime as $k=>$increment_prime) {
    if ($k == 'row') {
      $r = '<h3>PRIMARY MATRIX: (Primes) Original Matrix</h3>';
      foreach ($increment_prime as $ke=>$direction) {
        if ($ke == 'forward') {
          $r .= '';
          $r .= '<p></p><div class="endtext"><br></div>';
          $count = 1;
          $r .= '<table class="table"><tr>';
          foreach ($direction as $prime_row) {
            $r .= '<td class="tdgridltfirst">Row ' . $count .': </td>';
            foreach ($prime_row as $key=>$item) {
              if (in_array($item, $primes)) {
                $r .= '<td class="tdgrid subhighlight">' . $item . '</td>';
              }
              if (!in_array($item, $primes)) {
                $r .= '<td class="tdgrid">' . $item . '</td>';
              }
              if ($key == 0) {
                $zero = $item;
              }
              if ($key == 1) {
                $one = $item;
              }
              if ($key == 2) {
                $two = $item;
              }
              if ($key == 3) {
                $three = $item;
              }
              if ($key == 4) {
                $four = $item;
              }
            }

            if (isset($three) && isset($one) && $three == $one) {
              $upper = $one;
            } else {
              unset($upper);
            }
            if (isset($four) && $two == $four) {
              $lower = $two;
            } else {
              unset($lower);
            }

            if (isset($upper)) {

              foreach ($harmonics as $note) {
                $explode = explode(':', $note);
                if (isset($lower) && $explode[0] == $upper && $explode[1] == $lower && !empty($explode[2])) {
                  $r .= '<td class="tdgrid"><strong>' . $explode[2] . '</strong></td>';
                  $note_order[]= $explode[3];
                  $lower = (int)$lower;
                  $upper = (int)$upper; $added = $upper+$lower;
                  if (is_numeric($upper) && is_numeric($lower)) {
                    $r .= '<td>' . $upper . '+' . $lower . '=<strong>' . $added . '</strong></td>';
                  }
                  $lambdoma_map[$k][$ke][$key][$count]['lower'] = $explode[0];
                  $lambdoma_map[$k][$ke][$key][$count]['upper'] = $explode[1];
                  $lambdoma_map[$k][$ke][$key][$count]['key'] = $explode[2];
                  if ($explode[2] == 'origin') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'black';
                  }
                  if ($explode[2] == 'C') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zcee';
                  }
                  elseif ($explode[2] == 'C#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zceesharp';
                  }
                  elseif ($explode[2] == 'D') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zdee';
                  }
                  elseif ($explode[2] == 'Eb') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zeeeflat';
                  }
                  elseif ($explode[2] == 'E') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zeee';
                  }
                  elseif ($explode[2] == 'F') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zeff';
                  }
                  elseif ($explode[2] == 'F#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zeffsharp';
                  }
                  elseif ($explode[2] == 'G') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zgee';
                  }
                  elseif ($explode[2] == 'G#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zgeesharp';
                  }
                  elseif ($explode[2] == 'A') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zay';
                  }
                  elseif ($explode[2] == 'Bb') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zbeeflat';
                  }
                  elseif ($explode[2] == 'B') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'zbee';
                  }
                  else {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'darkslategray';
                  }
                  if (isset($explode[3])) {
                    $lambdoma_map[$k][$ke][$key][$count]['frequency'] = $explode[3];
                  }
                }
              }
            }
            $r .= '</tr>';
            $count++;
          }
          $r .= '</table>';
          $r .= '<h3>Order of frequencies: based on a ' . $frequency . 'Hz baseline or "C"</h3><ol>';
          if (isset($note_order)) {
            foreach ($note_order as $key => $hz) {

              $r .= '<li>' . $hz . 'Hz</li>';
            }
          }
          $r .= '</ol><hr>';
          $r .= '<div class="endtext"><br></div>';
          if (isset($note_order)) {
            $note_assembly[$ke]['r'][] = $note_order;
          }
        }
        if ($ke == 'derivative') {
          unset($note_order);
          $rd = '<h4>First Derivative: (Primes)</h4>';
          $count = 1;
          $rd .= '<table class="table"><tr>';
          foreach ($direction as $prime_row) {
            $rd .= '<td class="tdgridltfirst">Row ' . $count .': </td>';
            foreach ($prime_row as $key=>$item) {
              if (in_array($item, $primes)) {
                $rd .= '<td class="tdgrid subhighlight">' . $item . '</td>';
              }
              if (!in_array($item, $primes)) {
                $rd .= '<td class="tdgrid">' . $item . '</td>';
              }
              if ($key == 0) {
                $zero = $item;
              }
              if ($key == 1) {
                $one = $item;
              }
              if ($key == 2) {
                $two = $item;
              }
              if ($key == 3) {
                $three = $item;
              }
              if ($key == 4) {
                $four = $item;
              }
            }

            if (isset($three) && isset($one) && $three == $one) {
              $upper = $one;
            } else {
              unset($upper);
            }
            if (isset($four) && $two == $four) {
              $lower = $two;
            } else {
              unset($lower);
            }

            if (isset($upper)) {

              foreach ($harmonics as $note) {
                $explode = explode(':', $note);
                if (isset($lower) && $explode[0] == $upper && $explode[1] == $lower && !empty($explode[2])) {
                  $rd .= '<td class="tdgrid"><strong>' . $explode[2] . '</strong></td>';
                  $note_order[]= $explode[3];
                  $lower = (int)$lower;
                  $upper = (int)$upper; $added = $upper+$lower;
                  if (is_numeric($upper) && is_numeric($lower)) {
                    $rd .= '<td>' . $upper . '+' . $lower . '=<strong>' . $added . '</strong></td>';
                  }
                  $lambdoma_map[$k][$ke][$key][$count]['lower'] = $explode[0];
                  $lambdoma_map[$k][$ke][$key][$count]['upper'] = $explode[1];
                  $lambdoma_map[$k][$ke][$key][$count]['key'] = $explode[2];
                  if ($explode[2] == 'origin') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'black';
                  }

                  if ($explode[2] == 'C') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'cee';
                  }
                  elseif ($explode[2] == 'C#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'ceesharp';
                  }
                  elseif ($explode[2] == 'D') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'dee';
                  }
                  elseif ($explode[2] == 'Eb') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'eeeflat';
                  }
                  elseif ($explode[2] == 'E') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'eee';
                  }
                  elseif ($explode[2] == 'F') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'eff';
                  }
                  elseif ($explode[2] == 'F#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'effsharp';
                  }
                  elseif ($explode[2] == 'G') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'gee';
                  }
                  elseif ($explode[2] == 'G#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'geesharp';
                  }
                  elseif ($explode[2] == 'A') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'ay';
                  }
                  elseif ($explode[2] == 'Bb') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'beeflat';
                  }
                  elseif ($explode[2] == 'B') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'bee';
                  }
                  else {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'darkslategray';
                  }
                  if (isset($explode[3])) {
                    $lambdoma_map[$k][$ke][$key][$count]['frequency'] = $explode[3];
                  }
                }
              }
            }
            $rd .= '</tr>';
            $count++;
          }
          $rd .= '</table>';
          $rd .= '<h3>Order of frequencies: based on a ' . $frequency . 'Hz baseline or "C"</h3><ol>';
          if (isset($note_order)) {
            foreach ($note_order as $key => $hz) {

              $rd .= '<li>' . $hz . 'Hz</li>';
            }
          }
          $rd .= '</ol><hr>';
          $rd .= '<div class="endtext"><br></div>';
          if (isset($note_order)) {
            $note_assembly[$ke]['rd'][] = $note_order;
          }
        }
        if ($ke == 'derivative_2') {
          unset($note_order);
          $rd2 = '<h4>Second Derivative: (Primes)</h4>';
          $count = 1;
          $rd2 .= '<table class="table"><tr>';
          foreach ($direction as $prime_row) {
            $rd2 .= '<td class="tdgridltfirst">Row ' . $count .': </td>';
            foreach ($prime_row as $key=>$item) {
              if (in_array($item, $primes)) {
              }
              if (!in_array($item, $primes)) {
                $rd2 .= '<td class="tdgrid">' . $item . '</td>';
              }
              if ($key == 0) {
                $zero = $item;
              }
              if ($key == 1) {
                $one = $item;
              }
              if ($key == 2) {
                $two = $item;
              }
              if ($key == 3) {
                $three = $item;
              }
              if ($key == 4) {
                $four = $item;
              }
            }

            if (isset($three) && isset($one) && $three == $one) {
              $upper = $one;
            } else {
              unset($upper);
            }
            if (isset($four) && $two == $four) {
              $lower = $two;
            } else {
              unset($lower);
            }

            if (isset($upper)) {

              foreach ($harmonics as $note) {
                $explode = explode(':', $note);
                if (isset($lower) && $explode[0] == $upper && $explode[1] == $lower && !empty($explode[2])) {
                  $rd2 .= '<td class="tdgrid"><strong>' . $explode[2] . '</strong></td>';
                  $note_order[]= $explode[3];
                  $lower = (int)$lower;
                  $upper = (int)$upper; $added = $upper+$lower;
                  if (is_numeric($upper) && is_numeric($lower)) {
                    $rd2 .= '<td>' . $upper . '+' . $lower . '=<strong>' . $added . '</strong></td>';
                  }
                  $lambdoma_map[$k][$ke][$key][$count]['lower'] = $explode[0];
                  $lambdoma_map[$k][$ke][$key][$count]['upper'] = $explode[1];
                  $lambdoma_map[$k][$ke][$key][$count]['key'] = $explode[2];
                  if ($explode[2] == 'origin') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'black';
                  }
                  if ($explode[2] == 'C') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'cee';
                  }
                  elseif ($explode[2] == 'C#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'ceesharp';
                  }
                  elseif ($explode[2] == 'D') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'dee';
                  }
                  elseif ($explode[2] == 'Eb') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'eeeflat';
                  }
                  elseif ($explode[2] == 'E') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'eee';
                  }
                  elseif ($explode[2] == 'F') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'eff';
                  }
                  elseif ($explode[2] == 'F#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'effsharp';
                  }
                  elseif ($explode[2] == 'G') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'gee';
                  }
                  elseif ($explode[2] == 'G#') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'geesharp';
                  }
                  elseif ($explode[2] == 'A') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'ay';
                  }
                  elseif ($explode[2] == 'Bb') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'beeflat';
                  }
                  elseif ($explode[2] == 'B') {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'bee';
                  }
                  else {
                    $lambdoma_map[$k][$ke][$key][$count]['class'] = 'darkslategray';
                  }
                  if (isset($explode[3])) {
                    $lambdoma_map[$k][$ke][$key][$count]['frequency'] = $explode[3];
                  }
                }
              }
            }
            $rd2 .= '</tr>';
            $count++;
          }
          $rd2 .= '</table>';
          $rd2 .= '<h3>Order of frequencies: based on a ' . $frequency . 'Hz baseline or "C"</h3><ol>';
          if (isset($note_order)) {
            foreach ($note_order as $key => $hz) {

              $rd2 .= '<li>' . $hz . 'Hz</li>';
            }
          }
          $rd2 .= '</ol><hr>';
          $rd2 .= '<div class="endtext"><br></div>';
          if (isset($note_order)) {
            $note_assembly[$ke]['rd2'][] = $note_order;
          }
        }
      }
    }
  }
  $output .= $r;

  /*$output .= '<table><tr><th>k</th><th>ke</th><th>key</th><th>row</th><th>note</th><th>lower</th><th>upper</th></tr>';
  foreach($lambdoma_map as $k => $data) {
    foreach($data as $ke => $stuff) {
      foreach ($stuff as $key => $counts) {
        foreach ($counts as $count => $values) {
          $output .= "<tr><td>" . $k . "</td><td>" . $ke . "</td><td>" . $key . "</td><td>" . $count . "</td><td>" . $values['key'] . "</td><td>" . $values['lower'] . "</td><td>" . $values['upper'] . "</td></tr>";
        }
      }
    }
  }
  $output .= "</table>";*/
  $map = [];
  foreach ($lambdoma_map as $k => $data) {
    foreach ($data as $ke => $stuff) {
      //if ($ke = 'forward' || $k = 'row') {*/
        foreach ($stuff as $key => $counts) {
          foreach ($counts as $count => $values) {
            //dpm($values);
            for ($u = 0; $u <= 16; $u++) {
              for ($l = 0; $l <= 16; $l++) {
                if (!in_array($values['upper'] . ':' . $values['lower'] . ':' . $values['class'] . ':' . $values['frequency'] . ':' . $values['key'], $map)) {
                  $map[] = $values['upper'] . ':' . $values['lower'] . ':' . $values['class'] . ':' . $values['frequency'] . ':' . $values['key'];
                }
              }
            }
          }
        }
      //}
    }
  }

  //dpm($map);


  $output .= '<h3>Lambdoma Keyboard (<a href="http://lambdoma.com" target="_blank">Barbara Hero</a>) colored in with the locally determined frequency , and the letter note values based on a 256Hz C.</h3><table><tr><th></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th><th>16</th></tr>';
  for ($u=0; $u<=16; $u++) {
    $output .= '<tr>';
    $output .= '<td>' . $u . '</td>';


    for ($l = 0; $l <= 16; $l++) {
      $class = 'white';
      foreach ($map as $n => $unexploded) {
        $exploded = explode(':', $unexploded);
        if ($exploded[0] == $l && $exploded[1] == $u && !empty($explode[2])) {
          $np = 'b' . $n;
          if ($n >= $tone ) {
            $np = $n - $tone;
            $np = 'f' . $np;
          }
          $class = $exploded[2];
          $freq = $exploded[3];
          $kay = $exploded[4] . ':' . $np;
          //$output .= '<td>' . $u . '</td>';
        }
        if ($class == 'white') {
          if ($l == 0) {
            $class = 'lightgray';
          }
          elseif ($u == 0) {
            $class = 'lightgray';
          }
        }
      }
      $output .= '<td class ="' . $class . '">' . $u . '/' . $l . '<br>';
      if (isset($freq) && $freq != 'INF' && $class != 'white' && $class != 'lightgray') {
        $output .= intval($freq) . 'Hz<br>' . $kay . '</td>';
      }
      elseif (isset($freq) && $freq == 'INF') {
        $output .= 'INF</td>';
      }
      else {
        $output .= '-<br>-</td>';
      }
    }
    $output .= '</tr>';
  }
  $output .= '</table>';

  if (isset($rd)) {
    $output .= $rd;
  }
  if (isset($rd2)) {
    $output .= $rd2;
  }

  $output .= '</div><hr class="hr"><br>';

  $output .= '<h2>Solving for the 3D: extrapolating the matrix into 3 dimensions creating a fabric that is infinitely scalable in 6 directions: a sample using waveform pairs form the 13/20 matrix:</h2>';
  $output .= '<img src="/sites/default/files/2019-07/jellomatrix_1320_3d_0.png" width="100%" height="auto" /><hr>';

  $output .= '<div class="begintext"><p><a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png" /></a><br /><span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/InteractiveResource" property="dct:title" rel="dct:type">Jellomatrix</span> by <a xmlns:cc="http://creativecommons.org/ns#" href="https://www.jellobrain.com" property="cc:attributionName" rel="cc:attributionURL">Ana Willem</a> is licensed since 2007 under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License</a>.<br />Based on a work at <a xmlns:dct="http://purl.org/dc/terms/" href="https://www.jellobrain.com" rel="dct:source">https://www.jellobrain.com</a>.</p></div><hr class="hr">';
//dpm($note_assembly);

  //dpm($note_assembly);
  return $output;
}
